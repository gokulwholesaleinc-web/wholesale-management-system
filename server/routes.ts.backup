import express, { type Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import userRoutes from "./routes/users";
import statsRoutes from "./routes/stats";
import orderRoutes from "./routes/orders";
import { z } from "zod";
import {
  insertCartItemSchema,
  insertOrderSchema,
  insertOrderItemSchema,
  insertDeliveryAddressSchema,
  products,
  cartItems,
  deliveryAddresses
} from "@shared/schema";
import { db } from "./db";
import multer from "multer";
import path from "path";
import fs from "fs";
import { sql, eq } from "drizzle-orm";
import cookieParser from "cookie-parser";
import { requireAuth, requireAdmin, requireEmployeeOrAdmin, createAuthToken, validateToken } from "./simpleAuth";

export async function registerRoutes(app: Express): Promise<Server> {
  // Serve static files from public directory
  app.use('/images', express.static(path.join(process.cwd(), 'public/images')));
  app.use('/assets', express.static(path.join(process.cwd(), 'public/assets')));
  
  // Middleware to add CORS headers
  app.use((req, res, next) => {
    res.header('Access-Control-Allow-Origin', '*');
    res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
    next();
  });
  
  // Parse cookies for authentication
  app.use(cookieParser());
  
  // Register user management routes
  app.use('/api', userRoutes);
  
  // Emergency clear cart route - accessible without auth
  app.delete('/api/emergency-clear-cart/:userId', async (req, res) => {
    try {
      const { userId } = req.params;
      console.log('🔥 EMERGENCY CART WIPE REQUESTED FOR:', userId);
      
      try {
        // Use the most direct method
        const { pool } = await import('./db');
        await pool.query('DELETE FROM cart_items WHERE user_id = $1', [userId]);
        console.log('✅ Cart cleared successfully for:', userId);
      } catch (err) {
        console.error('❌ Error clearing cart:', err);
      }
      
      return res.json({
        success: true,
        message: 'Cart items cleared'
      });
    } catch (error) {
      console.error('💥 Critical error clearing cart:', error);
      return res.status(500).json({
        success: false,
        message: 'Failed to clear cart items'
      });
    }
  });
  
  // ADMIN ONLY - Reset all admin cart items with special handling
  app.post('/api/admin-reset-cart', async (req, res) => {
    try {
      console.log('⭐️ NUCLEAR CART CLEAR REQUESTED FOR: admin-user');
      
      console.log('Attempt 1: Using storage API');
      try {
        await storage.clearCart('admin-user');
        console.log('✓ Cart cleared successfully with storage API');
      } catch (error) {
        console.error('× Failed to clear cart with storage API:', error);
      }
      
      console.log('Attempt 2: Using direct SQL');
      try {
        const { pool } = await import('./db');
        await pool.query('DELETE FROM cart_items WHERE user_id = $1', ['admin-user']);
        console.log('✓ Direct SQL delete successful');
      } catch (error) {
        console.error('× Failed to clear cart with direct SQL:', error);
      }
      
      console.log('Attempt 3: Using Drizzle ORM');
      try {
        await db.delete(cartItems).where(eq(cartItems.userId, 'admin-user'));
        console.log('✓ Drizzle delete successful');
      } catch (error) {
        console.error('× Failed to clear cart with Drizzle:', error);
      }
      
      console.log('🧨 ABSOLUTE NUCLEAR CART WIPE FOR: admin-user');
      try {
        // Raw SQL for maximum compatibility
        await db.execute(sql`DELETE FROM cart_items WHERE user_id = 'admin-user'`);
        console.log('✓ Raw SQL delete executed');
      } catch (error) {
        console.error('× Failed raw SQL delete:', error);
      }
      
      console.log('✓ NUCLEAR CART CLEAR COMPLETED WITH ALL METHODS');
      
      return res.json({
        success: true,
        message: 'Admin cart has been completely cleared using all available methods'
      });
    } catch (error) {
      console.error('💥 Critical error in admin cart reset:', error);
      return res.status(500).json({
        success: false, 
        message: 'Failed to reset admin cart'
      });
    }
  });
  
  // Simple cart update route - no validation (for emergency use)
  app.put('/api/simple-update-cart-item', async (req, res) => {
    try {
      const { userId, productId, quantity } = req.body;
      
      if (!userId || !productId || !quantity) {
        return res.status(400).json({ 
          success: false,
          message: 'Missing required fields' 
        });
      }
      
      const existingItem = await storage.getCartItemByUserAndProduct(userId, productId);
      
      if (existingItem) {
        await storage.updateCartItem(userId, productId, quantity);
      } else {
        await storage.addToCart({
          userId,
          productId,
          quantity
        });
      }
      
      return res.json({
        success: true,
        message: 'Cart item updated'
      });
    } catch (error) {
      console.error('Error updating cart item:', error);
      return res.status(500).json({
        success: false,
        message: 'Failed to update cart item'
      });
    }
  });
  
  // Simple cart remove route - no validation (for emergency use)
  app.delete('/api/simple-remove-from-cart', async (req, res) => {
    try {
      const { userId, productId } = req.body;
      
      if (!userId || !productId) {
        return res.status(400).json({ 
          success: false,
          message: 'Missing required fields' 
        });
      }
      
      await storage.removeFromCart(userId, productId);
      
      return res.json({
        success: true,
        message: 'Item removed from cart'
      });
    } catch (error) {
      console.error('Error removing item from cart:', error);
      return res.status(500).json({
        success: false,
        message: 'Failed to remove item from cart'
      });
    }
  });
  
  // Simple get cart for a user - more direct approach than normal endpoint
  app.get('/api/simple-get-cart/:userId', async (req, res) => {
    try {
      const { userId } = req.params;
      
      if (!userId) {
        return res.status(400).json({ 
          success: false,
          message: 'User ID is required' 
        });
      }
      
      const cartItems = await storage.getCartItems(userId);
      
      return res.json(cartItems);
    } catch (error) {
      console.error('Error fetching cart items:', error);
      return res.status(500).json({
        success: false,
        message: 'Failed to fetch cart items'
      });
    }
  });
  // Set up our cookie parser for auth tokens
  app.use(cookieParser());
  
  // Redirect any /api/login requests to our static login page
  app.get('/api/login', (req, res) => {
    res.sendFile(path.join(process.cwd(), 'public', 'login.html'));
  });
  
  // Serve the static login page for /login directly
  app.get('/login', (req, res) => {
    res.sendFile(path.join(process.cwd(), 'public', 'login.html'));
  });
  
  // Also serve login.html directly
  app.get('/login.html', (req, res) => {
    res.sendFile(path.join(process.cwd(), 'public', 'login.html'));
  });
  
  // Serve static files from the uploads directory
  const uploadsDir = path.join(process.cwd(), 'public', 'uploads');
  // Create directory if it doesn't exist
  if (!fs.existsSync(uploadsDir)) {
    fs.mkdirSync(uploadsDir, { recursive: true });
  }
  app.use('/uploads', express.static(uploadsDir));
  
  // We will handle client-side routing in index.ts
  
  // Configure multer storage for file uploads
  const fileStorage = multer.diskStorage({
    destination: (req, file, cb) => {
      const uploadDir = path.join(process.cwd(), 'public', 'uploads');
      // Create directory if it doesn't exist
      if (!fs.existsSync(uploadDir)) {
        fs.mkdirSync(uploadDir, { recursive: true });
      }
      cb(null, uploadDir);
    },
    filename: (req, file, cb) => {
      // Create unique filename with original extension
      const uniqueName = `${Date.now()}-${Math.round(Math.random() * 1E9)}${path.extname(file.originalname)}`;
      cb(null, uniqueName);
    }
  });
  
  // Set up multer upload middleware
  const upload = multer({ 
    storage: fileStorage,
    limits: { fileSize: 5 * 1024 * 1024 }, // 5MB limit
    fileFilter: (req, file, cb) => {
      // Only allow image files
      const filetypes = /jpeg|jpg|png|gif|webp/;
      const mimetype = filetypes.test(file.mimetype);
      const extname = filetypes.test(path.extname(file.originalname).toLowerCase());
      
      if (mimetype && extname) {
        return cb(null, true);
      }
      
      cb(new Error("Only image files are allowed"));
    }
  });
  
  // Use user routes
  app.use('/api/users', userRoutes);
  
  // Use stats routes
  app.use('/api/stats', statsRoutes);
  
  // Use order routes
  app.use('/api/orders', orderRoutes);
  
  // Special endpoint for staff to view all orders
  app.get("/api/staff/orders", async (req: any, res) => {
    // Extract token directly from headers
    const token = req.headers['x-auth-token'] || req.headers.authorization?.split(' ')[1];
    if (!token) {
      return res.status(401).json({ message: 'No authentication token provided' });
    }

    // Special case for admin tokens (which are in format 'admin-token-{timestamp}')
    if (token.startsWith('admin-token-')) {
      // This is the admin - set default admin user
      req.user = {
        id: 'admin-user',
        username: 'admin',
        isAdmin: true
      };
    } else {
      // Handle regular tokens
      const userId = validateToken(token);
      if (!userId) {
        return res.status(401).json({ message: 'Invalid or expired token' });
      }

      // For regular users, try to find them in the database
      try {
        const user = await storage.getUser(userId);
        if (!user) {
          // Special fallback for admin user if token is valid but user not found in DB
          if (userId === 'admin-user') {
            req.user = {
              id: 'admin-user',
              username: 'admin',
              isAdmin: true
            };
            // Continue with processing
          } else {
            return res.status(401).json({ message: 'User not found' });
          }
        } else {
          // Check if user is admin or employee
          if (!user.isAdmin && !user.isEmployee) {
            return res.status(403).json({ message: 'Staff access required' });
          }

          // Set req.user for use in the rest of the handler
          req.user = user;
        }
      } catch (error) {
        console.error('Error fetching user:', error);
        return res.status(500).json({ message: 'Internal server error' });
      }
    }
    try {
      // Get all orders for staff to manage
      const orders = await storage.getAllOrders();
      
      // Return the orders with customer information
      const ordersWithCustomerInfo = await Promise.all(
        orders.map(async (order) => {
          const user = await storage.getUser(order.userId);
          return {
            ...order,
            customerName: user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() || user.username : 'Unknown'
          };
        })
      );
      
      res.json(ordersWithCustomerInfo);
    } catch (error) {
      console.error("Error fetching staff orders:", error);
      res.status(500).json({ message: "Failed to fetch orders" });
    }
  });
  
  // ABSOLUTE NUCLEAR option - direct DB access for cart clearing
  app.delete("/api/emergency-clear-cart/:userId", async (req, res) => {
    try {
      const { userId } = req.params;
      console.log("*** ABSOLUTE NUCLEAR CART WIPE REQUESTED FOR:", userId);
      
      if (!userId) {
        return res.status(400).json({ message: "User ID required" });
      }
      
      try {
        // Use storage API directly - most reliable
        await storage.clearCart(userId);
        console.log("✓ STORAGE LAYER CLEARED");
        
        // Also use raw Drizzle delete as a backup
        try {
          await db.delete(cartItems).where(eq(cartItems.userId, userId));
          console.log("✓ DRIZZLE DELETE SUCCESSFUL");
        } catch (err) {
          console.log("Drizzle delete failed:", err);
        }
        
        // Return immediate success
        return res.json({ 
          success: true,
          cleared: true,
          message: "Cart completely wiped with absolute nuclear option",
          time: new Date().toISOString()
        });
      } catch (dbError: any) {
        console.error("NUCLEAR CART DELETE FAILED:", dbError?.message || dbError);
        
        // Last resort - attempt raw SQL through drizzle
        try {
          console.log("Attempting last resort direct SQL");
          await db.execute(sql`DELETE FROM cart_items WHERE user_id = ${userId}`);
          
          return res.json({
            success: true,
            cleared: true,
            message: "Cart cleared with last resort method",
            time: new Date().toISOString()
          });
        } catch (lastError: any) {
          console.error("LAST RESORT ALSO FAILED:", lastError?.message || lastError);
          return res.status(500).json({ 
            message: "All cart clearing methods failed",
            error: lastError?.message || "Unknown database error"
          });
        }
      }
    } catch (error: any) {
      console.error("GENERAL ERROR during cart nuclear wipe:", error?.message || error);
      return res.status(500).json({ 
        message: "Failed to clear cart", 
        error: error?.message || "Unknown error"
      });
    }
  });

  // Auth routes
  app.get('/api/auth/user', requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      res.json(user);
    } catch (error) {
      console.error("Error fetching user:", error);
      res.status(500).json({ message: "Failed to fetch user" });
    }
  });

  // Categories routes
  app.get("/api/categories", async (req, res) => {
    try {
      const categories = await storage.getCategories();
      res.json(categories);
    } catch (error) {
      console.error("Error fetching categories:", error);
      res.status(500).json({ message: "Failed to fetch categories" });
    }
  });

  // Products routes
  app.get("/api/products", async (req, res) => {
    try {
      const categoryId = req.query.categoryId ? parseInt(req.query.categoryId as string) : undefined;
      console.log("Fetching products for categoryId:", categoryId);
      
      const products = await storage.getProducts(categoryId);
      console.log(`Fetched ${products.length} products from database`);
      
      // Transform products to ensure consistent field naming
      const transformedProducts = products.map(product => {
        // Make sure imageUrl field is consistently named and available
        return {
          ...product,
          // Ensure imageUrl is always available
          imageUrl: product.imageUrl || 
                   // Use any image URL properties that might come from database
                   (product as any).image_url || 
                   // Default fallback to ensure there's always something
                   '',
          // Use a single price for all users - removing the tier system
          price: product.price1 !== null ? product.price1 : product.price,
        };
      });
      
      // Log sample product after transformation
      if (transformedProducts.length > 0) {
        console.log("Sample product:", JSON.stringify(transformedProducts[0]).substring(0, 200) + "...");
      }
      
      res.json(transformedProducts);
    } catch (error) {
      console.error("Error fetching products:", error);
      res.status(500).json({ message: "Failed to fetch products" });
    }
  });
  
  // API endpoint for personalized product recommendations
  app.get("/api/recommendations", async (req: any, res) => {
    try {
      const limit = req.query.limit ? parseInt(req.query.limit as string) : 10;
      
      // Fetch all products with valid images
      const allProducts = await storage.getProducts();
      
      // **NEW FEATURE**: 
      // Dynamic featured product rotation based on 10-day cycles
      // Get the current date cycle (changes every 10 days)
      const today = new Date();
      const startOfYear = new Date(today.getFullYear(), 0, 0);
      const dayOfYear = Math.floor((today.getTime() - startOfYear.getTime()) / (1000 * 60 * 60 * 24));
      const tenDayCycle = Math.floor(dayOfYear / 10); // Changes every 10 days
      
      // Determine which products should be featured in this cycle
      const productsWithImages = allProducts.filter(product => 
        product.imageUrl && 
        product.imageUrl.length > 10
      );
      
      // Use the current cycle to select different featured products
      const featuredProductCount = Math.min(8, Math.floor(productsWithImages.length / 4));
      const featuredIndexStart = (tenDayCycle * featuredProductCount) % Math.max(1, productsWithImages.length - featuredProductCount);
      
      // Create a set of featured product IDs for this cycle
      const featuredProductIds = new Set(
        productsWithImages
          .slice(featuredIndexStart, featuredIndexStart + featuredProductCount)
          .map(p => p.id)
      );
      
      console.log(`10-day cycle #${tenDayCycle}: Featuring ${featuredProductIds.size} products starting at index ${featuredIndexStart}`);
      
      // Logic for recommendations:
      // 1. Ensure products have valid images
      // 2. Prioritize dynamic featured products for this 10-day cycle
      // 3. Prioritize products with higher stock
      
      const filteredProducts = allProducts
        .filter(product => 
          // Must have a valid image URL
          product.imageUrl && 
          product.imageUrl.length > 10
        )
        .sort((a, b) => {
          // Prioritize dynamically featured products for this cycle
          const aIsFeatured = featuredProductIds.has(a.id);
          const bIsFeatured = featuredProductIds.has(b.id);
          
          if (aIsFeatured && !bIsFeatured) return -1;
          if (!aIsFeatured && bIsFeatured) return 1;
          
          // Prioritize products with higher stock
          return b.stock - a.stock;
        });
      
      // Transform products for consistent field naming
      const recommendations = filteredProducts.slice(0, limit).map(product => {
        return {
          ...product,
          priceLevel1: product.price1 || product.price,
          priceLevel2: product.price2 || product.price * 0.97,
          priceLevel3: product.price3 || product.price * 0.95,
          priceLevel4: product.price4 || product.price * 0.93,
          priceLevel5: product.price5 || product.price * 0.90
        };
      });
      
      // If we don't have enough recommendations or user has no history, add some popular products
      if (recommendations.length < limit) {
        const popularProducts = allProducts
          .filter(product => 
            // Must have a valid image URL
            product.imageUrl && 
            product.imageUrl.length > 10 &&
            // Not already in recommendations
            !recommendations.some(rec => rec.id === product.id)
          )
          .sort((a, b) => {
            // Sort by featured status and then by stock (proxy for popularity)
            if (a.featured && !b.featured) return -1;
            if (!a.featured && b.featured) return 1;
            return b.stock - a.stock;
          })
          .slice(0, limit - recommendations.length)
          .map(product => ({
            ...product,
            priceLevel1: product.price1 || product.price,
            priceLevel2: product.price2 || product.price * 0.97,
            priceLevel3: product.price3 || product.price * 0.95,
            priceLevel4: product.price4 || product.price * 0.93,
            priceLevel5: product.price5 || product.price * 0.90
          }));
        
        recommendations.push(...popularProducts);
      }
      
      // Add a field to indicate recommendation reason
      const recommendationsWithReason = recommendations.map(product => {
        let reason = 'Popular product';
        
        if (product.featured) {
          reason = 'Featured product';
        }
        
        return {
          ...product,
          recommendationReason: reason
        };
      });
      
      res.json(recommendationsWithReason);
    } catch (error) {
      console.error("Error fetching recommendations:", error);
      res.status(500).json({ message: "Failed to fetch recommendations" });
    }
  });

  app.get("/api/products/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const product = await storage.getProductById(id);
      
      if (!product) {
        return res.status(404).json({ message: "Product not found" });
      }
      
      res.json(product);
    } catch (error) {
      console.error("Error fetching product:", error);
      res.status(500).json({ message: "Failed to fetch product" });
    }
  });
  
  // Admin product management routes
  app.get("/api/admin/products", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      
      // Check for special admin user first
      const isHardcodedAdmin = userId === 'admin-user';
      
      // If not hardcoded admin, check database
      let isDbAdmin = false;
      if (!isHardcodedAdmin) {
        const user = await storage.getUser(userId);
        isDbAdmin = user?.isAdmin === true;
      }
      
      // Combine checks
      const isAdmin = isHardcodedAdmin || isDbAdmin;
      
      if (!isAdmin) {
        console.log('User is not an admin:', userId);
        return res.status(403).json({ message: "Unauthorized" });
      }
      
      console.log('Admin user authenticated, fetching all products');
      
      // Get all products for admin (no category filter)
      const products = await storage.getProducts();
      console.log(`Found ${products.length} products for admin display`);
      
      // Transform products to ensure consistent field naming
      const transformedProducts = products.map(product => {
        return {
          ...product,
          imageUrl: product.imageUrl || '',
          price: product.price1 !== null ? product.price1 : product.price,
        };
      });
      
      res.json(transformedProducts);
    } catch (error) {
      console.error("Error fetching admin products:", error);
      res.status(500).json({ message: "Failed to fetch products" });
    }
  });
  
  // Endpoint to update product category (for merging SODA into FOOD & BEVERAGE)
  app.post("/api/admin/categories/merge", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      
      if (!user?.isAdmin) {
        return res.status(403).json({ message: "Unauthorized" });
      }
      
      const { sourceCategory, targetCategory } = req.body;
      
      if (!sourceCategory || !targetCategory) {
        return res.status(400).json({ message: "Source and target category IDs are required" });
      }
      
      // Get all products from source category
      const products = await storage.getProducts(sourceCategory);
      
      // Update each product to the target category
      for (const product of products) {
        await storage.updateProduct(product.id, {
          categoryId: targetCategory
        });
      }
      
      res.json({ 
        message: `Successfully moved ${products.length} products from category ${sourceCategory} to ${targetCategory}`,
        count: products.length
      });
    } catch (error) {
      console.error("Error merging categories:", error);
      res.status(500).json({ message: "Failed to merge categories" });
    }
  });
  
  // Special route for admin image management - less restrictive
  app.get("/api/admin/products/images", async (req: any, res) => {
    try {
      // Get all products for admin image management
      const products = await storage.getProducts();
      
      // Just return basic product info needed for image management
      const transformedProducts = products.map(product => ({
        id: product.id,
        name: product.name,
        description: product.description,
        imageUrl: product.imageUrl || '',
        categoryId: product.categoryId
      }));
      
      console.log(`Returning ${transformedProducts.length} products for image management`);
      return res.json(transformedProducts);
    } catch (error) {
      console.error("Error fetching products for image management:", error);
      res.status(500).json({ message: "Failed to fetch products" });
    }
  });
  
  // Admin product management routes
  app.get("/api/admin/products", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      
      // Check for special admin user first
      const isHardcodedAdmin = userId === 'admin-user';
      
      // If not hardcoded admin, check database
      let isDbAdmin = false;
      if (!isHardcodedAdmin) {
        const user = await storage.getUser(userId);
        isDbAdmin = user?.isAdmin === true;
      }
      
      // Combine checks
      const isAdmin = isHardcodedAdmin || isDbAdmin;
      
      if (!isAdmin) {
        console.log('User is not an admin:', userId);
        return res.status(403).json({ message: "Unauthorized" });
      }
      
      console.log('Admin user authenticated, fetching all products');
      
      // Get all products for admin (no category filter)
      const products = await storage.getProducts();
      console.log(`Found ${products.length} products for admin display`);
      
      // Transform products to ensure consistent field naming
      const transformedProducts = products.map(product => {
        return {
          ...product,
          imageUrl: product.imageUrl || '',
          price: product.price1 !== null ? product.price1 : product.price,
        };
      });
      
      console.log(`Returning ${transformedProducts.length} products to admin user`);
      return res.json(transformedProducts);
    } catch (error) {
      console.error("Error fetching admin products:", error);
      res.status(500).json({ message: "Failed to fetch products" });
    }
  });
  
  // API route to check if admin token is valid in cookies
  app.get("/api/check-admin-token", async (req: any, res) => {
    try {
      // Check cookies for admin token
      if (req.cookies?.authToken && req.cookies.authToken.startsWith('admin-token')) {
        console.log('Admin token found in cookies, granting access');
        
        // Get all products for admin (no category filter)
        const products = await storage.getProducts();
        
        // Transform products to ensure consistent field naming
        const transformedProducts = products.map(product => {
          return {
            ...product,
            imageUrl: product.imageUrl || '',
            price1: product.price1 || product.price,
            price2: product.price2 || product.price * 0.97,
            price3: product.price3 || product.price * 0.95,
            price4: product.price4 || product.price * 0.93,
            price5: product.price5 || product.price * 0.90
          };
        });
        
        console.log(`Returning ${transformedProducts.length} products to admin user`);
        return res.json(transformedProducts);
      }
      
      // If we reach here, no valid admin credentials found
      return res.status(403).json({ message: "Unauthorized" });
    } catch (error) {
      console.error("Error fetching admin products:", error);
      res.status(500).json({ message: "Failed to fetch products" });
    }
  });
  
  app.post("/api/admin/products", requireAdmin, async (req: any, res) => {
    try {
      
      const productData = req.body;
      
      // Basic validation
      if (!productData.name || !productData.price) {
        return res.status(400).json({ message: "Name and price are required" });
      }
      
      // If price is provided as a string, convert to number
      if (typeof productData.price === 'string') {
        productData.price = parseFloat(productData.price);
      }
      
      // Same for stock
      if (typeof productData.stock === 'string') {
        productData.stock = parseInt(productData.stock);
      }
      
      const product = await storage.createProduct(productData);
      res.status(201).json(product);
    } catch (error) {
      console.error("Error creating product:", error);
      res.status(500).json({ message: "Failed to create product" });
    }
  });
  
  app.put("/api/admin/products/:id", requireAdmin, async (req: any, res) => {
    try {
      
      const id = parseInt(req.params.id);
      const productData = req.body;
      
      // If price is provided as a string, convert to number
      if (typeof productData.price === 'string') {
        productData.price = parseFloat(productData.price);
      }
      
      // Same for stock
      if (typeof productData.stock === 'string') {
        productData.stock = parseInt(productData.stock);
      }
      
      const product = await storage.updateProduct(id, productData);
      
      if (!product) {
        return res.status(404).json({ message: "Product not found" });
      }
      
      res.json(product);
    } catch (error) {
      console.error("Error updating product:", error);
      res.status(500).json({ message: "Failed to update product" });
    }
  });
  
  // Admin routes - update product image specifically
  app.patch("/api/admin/products/:id/image", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      
      // Check for special admin user first
      const isHardcodedAdmin = userId === 'admin-user';
      
      // If not hardcoded admin, check database
      let isDbAdmin = false;
      if (!isHardcodedAdmin) {
        const user = await storage.getUser(userId);
        isDbAdmin = user?.isAdmin === true;
      }
      
      // Combine checks
      const isAdmin = isHardcodedAdmin || isDbAdmin;
      
      console.log('Admin image update permission check:', { 
        userId, 
        isHardcodedAdmin, 
        isDbAdmin, 
        isAdmin 
      });
      
      if (!isAdmin) {
        return res.status(403).json({ message: "Unauthorized" });
      }
      
      const id = parseInt(req.params.id);
      const { imageUrl } = req.body;
      
      if (!imageUrl) {
        return res.status(400).json({ message: "Image URL is required" });
      }
      
      console.log(`Updating product ${id} image to: ${imageUrl}`);
      
      // Update only the image URL field
      const product = await storage.updateProduct(id, { imageUrl });
      
      if (!product) {
        return res.status(404).json({ message: "Product not found" });
      }
      
      res.json(product);
    } catch (error) {
      console.error("Error updating product image:", error);
      res.status(500).json({ message: "Failed to update product image" });
    }
  });
  
  // Admin routes - upload product image file
  app.post("/api/admin/products/:id/upload", requireAuth, upload.single('image'), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      
      if (!user?.isAdmin) {
        return res.status(403).json({ message: "Unauthorized" });
      }
      
      const id = parseInt(req.params.id);
      
      if (!req.file) {
        return res.status(400).json({ message: "No image file uploaded" });
      }
      
      // Create URL for the uploaded file
      const baseUrl = `${req.protocol}://${req.get('host')}`;
      const imageUrl = `${baseUrl}/uploads/${req.file.filename}`;
      
      // Update product with the new image URL
      const product = await storage.updateProduct(id, { imageUrl });
      
      if (!product) {
        return res.status(404).json({ message: "Product not found" });
      }
      
      res.json({ 
        success: true, 
        imageUrl, 
        product 
      });
    } catch (error: any) {
      console.error("Error uploading product image:", error);
      res.status(500).json({ 
        message: "Failed to upload product image",
        error: error.message 
      });
    }
  });
  
  app.delete("/api/admin/products/:id", requireAdmin, async (req: any, res) => {
    try {
      
      const id = parseInt(req.params.id);
      
      await storage.deleteProduct(id);
      res.json({ message: "Product deleted successfully" });
    } catch (error) {
      console.error("Error deleting product:", error);
      res.status(500).json({ message: "Failed to delete product" });
    }
  });
  
  // Endpoint to delete products by name pattern (for cleanup)
  app.post("/api/admin/products/delete-by-pattern", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      
      if (!user?.isAdmin) {
        return res.status(403).json({ message: "Unauthorized" });
      }
      
      const { pattern } = req.body;
      
      if (!pattern) {
        return res.status(400).json({ message: "Pattern is required" });
      }
      
      // Find products matching the pattern
      const matchingProducts = await db.select()
        .from(products)
        .where(sql`name LIKE ${`%${pattern}%`}`);
      
      if (matchingProducts.length === 0) {
        return res.json({ 
          message: "No products found matching the pattern",
          deletedCount: 0 
        });
      }
      
      // Delete the products
      for (const product of matchingProducts) {
        await storage.deleteProduct(product.id);
      }
      
      res.json({ 
        message: `Successfully deleted ${matchingProducts.length} products matching pattern: ${pattern}`,
        deletedCount: matchingProducts.length,
        deletedProducts: matchingProducts.map(p => p.name)
      });
    } catch (error) {
      console.error("Error deleting products by pattern:", error);
      res.status(500).json({ message: "Failed to delete products" });
    }
  });

  // Special endpoint for admin to clear global cart (needed for clear cart button to work)
  app.delete('/api/admin/clear-global-cart', requireAuth, async (req: any, res) => {
    try {
      if (req.user?.id !== 'admin-user') {
        return res.status(403).json({ 
          success: false, 
          message: "Unauthorized access" 
        });
      }
      
      console.log('💥 ADMIN GLOBAL CART RESET REQUESTED');
      
      // Reset the global admin cart to an empty array
      globalAdminCart = [];
      
      console.log('✅ ADMIN GLOBAL CART RESET SUCCESSFUL');
      
      return res.json({
        success: true,
        message: 'Admin cart has been cleared completely'
      });
    } catch (error) {
      console.error('❌ Error clearing admin cart:', error);
      return res.status(500).json({
        success: false,
        message: 'Failed to clear admin cart'
      });
    }
  });

  // Special route to clear user's cart items (used for admin cart fix)
  app.delete('/api/users/clear-cart/:userId', async (req, res) => {
    try {
      const { userId } = req.params;
      console.log("⭐️ NUCLEAR CART CLEAR REQUESTED FOR:", userId);
      
      // Attempt 1: Using storage API
      try {
        if (userId === 'admin-user') {
          // Special handling for admin user
          console.log("Actually clearing cart for user:", userId);
          await storage.clearCart(userId);
          console.log("✓ Cart cleared successfully with storage API");
        }
      } catch (err) {
        console.error("Failed to clear cart with storage API:", err);
      }
      
      return res.json({
        success: true,
        message: `Cart cleared successfully for: ${userId}`
      });
    } catch (error) {
      console.error('Error clearing cart:', error);
      return res.status(500).json({
        error: 'Failed to clear cart'
      });
    }
  });
  
  // Cart routes - all protected
  // Global admin cart state to allow for persistence between requests
  // Starting with an empty cart to fix the admin cart persistence issue
  let globalAdminCart = [];

  // Direct cart update endpoint for admin user
  app.post('/api/update-cart-direct', async (req, res) => {
    try {
      const { userId, productId, quantity } = req.body;
      
      if (!userId || !productId || quantity === undefined) {
        return res.status(400).json({ 
          success: false, 
          message: "Missing required fields" 
        });
      }
      
      console.log(`⭐️ DIRECT CART UPDATE: User ${userId}, Product ${productId}, Quantity ${quantity}`);
      
      // Special handling for admin user - update in-memory cart
      if (userId === 'admin-user') {
        // Find the item in admin cart
        const itemIndex = globalAdminCart.findIndex(item => item.productId === parseInt(productId));
        
        if (itemIndex >= 0) {
          // Update existing item
          if (quantity <= 0) {
            // Remove item if quantity is 0 or negative
            globalAdminCart = globalAdminCart.filter(item => item.productId !== parseInt(productId));
            console.log(`Removed item ${productId} from admin cart`);
          } else {
            // Update quantity
            globalAdminCart[itemIndex].quantity = quantity;
            globalAdminCart[itemIndex].updatedAt = new Date();
            console.log(`Updated item ${productId} in admin cart to quantity ${quantity}`);
          }
        } else if (quantity > 0) {
          // Add new item if it doesn't exist and quantity is positive
          try {
            const product = await storage.getProductById(parseInt(productId));
            if (!product) {
              return res.status(404).json({ success: false, message: "Product not found" });
            }
            
            globalAdminCart.push({
              id: Date.now(), // Generate a unique ID
              userId: 'admin-user',
              productId: parseInt(productId),
              quantity,
              createdAt: new Date(),
              updatedAt: new Date(),
              product: {
                id: product.id,
                name: product.name,
                description: product.description || "",
                price: product.price,
                basePrice: product.basePrice || 0,
                imageUrl: product.imageUrl || "",
                stock: product.stock || 10
              }
            });
            console.log(`Added new item ${productId} to admin cart with quantity ${quantity}`);
          } catch (error) {
            console.error("Error adding product to admin cart:", error);
            return res.status(500).json({ success: false, message: "Error adding product to cart" });
          }
        }
        
        return res.json({
          success: true,
          message: "Cart updated successfully",
          cart: globalAdminCart
        });
      }
      
      // For regular users, update in database
      try {
        // Use storage API
        if (quantity <= 0) {
          await storage.removeFromCart(userId, parseInt(productId));
        } else {
          const updateResult = await storage.updateCartItem(userId, parseInt(productId), quantity);
          if (!updateResult) {
            // Item doesn't exist, add it
            await storage.addToCart({
              userId,
              productId: parseInt(productId),
              quantity
            });
          }
        }
        
        return res.json({
          success: true,
          message: "Cart updated successfully"
        });
      } catch (error: any) {
        console.error("Error updating cart:", error);
        return res.status(500).json({
          success: false,
          message: "Failed to update cart",
          error: error.message
        });
      }
    } catch (error: any) {
      console.error("Failed to process cart update:", error);
      return res.status(500).json({
        success: false,
        message: "Failed to update cart",
        error: error.message
      });
    }
  });
  
  app.get("/api/cart", requireAuth, async (req: any, res) => {
    try {
      // Our admin user has a special ID format
      const userId = req.user.id;
      console.log("Fetching cart for user:", userId);
      
      // Special case for admin user - return the global admin cart
      if (userId === 'admin-user') {
        return res.json(globalAdminCart);
      }
      
      const cartItems = await storage.getCartItems(userId);
      res.json(cartItems);
    } catch (error) {
      console.error("Error fetching cart:", error);
      res.status(500).json({ message: "Failed to fetch cart" });
    }
  });

  app.post("/api/cart", requireAuth, async (req: any, res) => {
    try {
      // Our admin user has a special ID format
      const userId = req.user.id;
      console.log("Adding to cart for user:", userId, "Product:", req.body.productId, "Quantity:", req.body.quantity);
      
      // Special case for admin user - use in-memory cart
      if (userId === 'admin-user') {
        console.log("Admin user - updating global admin cart");
        
        const productId = parseInt(req.body.productId);
        const quantity = parseInt(req.body.quantity);
        
        // Find the product in the admin cart
        const existingItemIndex = globalAdminCart.findIndex(item => item.productId === productId);
        
        if (existingItemIndex >= 0) {
          // Update existing item
          globalAdminCart[existingItemIndex].quantity = quantity;
          globalAdminCart[existingItemIndex].updatedAt = new Date();
          
          console.log(`Updated existing item: ${productId} to quantity ${quantity} in admin cart`);
          return res.status(200).json(globalAdminCart[existingItemIndex]);
        } else {
          // Add new item
          const product = await storage.getProductById(productId);
          
          if (!product) {
            return res.status(404).json({ message: "Product not found" });
          }
          
          const newItem = {
            id: Date.now(), // Generate a unique ID
            userId: 'admin-user',
            productId,
            quantity,
            createdAt: new Date(),
            updatedAt: new Date(),
            product: {
              id: product.id,
              name: product.name,
              description: product.description || "",
              price: product.price,
              basePrice: product.basePrice || 0,
              imageUrl: product.imageUrl || "",
              stock: product.stock || 10
            }
          };
          
          globalAdminCart.push(newItem);
          console.log(`Added new item to admin cart: ${productId} with quantity ${quantity}`);
          
          return res.status(201).json(newItem);
        }
      }
      
      const validatedData = insertCartItemSchema.parse({
        ...req.body,
        userId
      });
      
      // Verify the product exists and has enough stock
      const product = await storage.getProductById(validatedData.productId);
      if (!product) {
        return res.status(404).json({ message: "Product not found" });
      }
      
      if (product.stock < validatedData.quantity) {
        return res.status(400).json({ message: "Not enough stock available" });
      }
      
      const cartItem = await storage.addToCart(validatedData);
      res.status(201).json(cartItem);
    } catch (error) {
      console.error("Error adding to cart:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid cart data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to add to cart" });
    }
  });

  // Direct cart update API for consistent handling of cart operations
  app.post("/api/update-cart-direct", async (req: any, res) => {
    try {
      const { userId, productId, quantity } = req.body;
      
      console.log(`Direct cart update request - userId: ${userId}, productId: ${productId}, quantity: ${quantity}`);
      
      if (!userId || !productId || quantity === undefined) {
        return res.status(400).json({ 
          message: "Missing required fields", 
          details: { 
            userId: userId ? "Valid" : "Missing", 
            productId: productId ? "Valid" : "Missing", 
            quantity: quantity !== undefined ? "Valid" : "Missing"
          } 
        });
      }
      
      // Handle admin user separately 
      if (userId === 'admin-user') {
        console.log("Admin user - simulating direct cart update");
        
        // Find if item already exists in admin cart
        const existingItemIndex = globalAdminCart.findIndex(
          item => item.productId === productId
        );
        
        if (quantity <= 0) {
          // Remove item if quantity is 0 or less
          if (existingItemIndex !== -1) {
            globalAdminCart.splice(existingItemIndex, 1);
            console.log(`Removed item ${productId} from admin cart`);
          }
          return res.json({ message: "Item removed from admin cart" });
        }
        
        // Get product info for admin cart
        const product = await storage.getProductById(productId);
        if (!product) {
          return res.status(404).json({ message: "Product not found" });
        }
        
        if (existingItemIndex !== -1) {
          // Update existing admin cart item
          globalAdminCart[existingItemIndex].quantity = quantity;
          globalAdminCart[existingItemIndex].updatedAt = new Date();
          console.log(`Updated admin cart item ${productId} to quantity ${quantity}`);
          return res.json(globalAdminCart[existingItemIndex]);
        } else {
          // Add new admin cart item
          const newItem = {
            id: Date.now(),
            userId: 'admin-user',
            productId,
            quantity,
            createdAt: new Date(),
            updatedAt: new Date(),
            product: {
              id: product.id,
              name: product.name,
              description: product.description || "",
              price: product.price,
              basePrice: product.basePrice || 0,
              imageUrl: product.imageUrl || "",
              stock: product.stock || 10
            }
          };
          
          globalAdminCart.push(newItem);
          console.log(`Added new item to admin cart: ${productId} with quantity ${quantity}`);
          
          return res.json(newItem);
        }
      }
      
      // For regular users, use the database storage
      
      // Check if item exists in cart
      const existingItem = await storage.getCartItemByUserAndProduct(userId, productId);
      
      if (quantity <= 0) {
        // Remove item if quantity is 0 or less
        if (existingItem) {
          await storage.removeFromCart(userId, productId);
          console.log(`Removed item ${productId} from user ${userId} cart`);
        }
        return res.json({ message: "Item removed from cart" });
      }
      
      // Verify the product exists and has enough stock
      const product = await storage.getProductById(productId);
      if (!product) {
        return res.status(404).json({ message: "Product not found" });
      }
      
      if (product.stock < quantity) {
        return res.status(400).json({ message: "Not enough stock available" });
      }
      
      if (existingItem) {
        // Update existing cart item
        const updatedItem = await storage.updateCartItem(userId, productId, quantity);
        console.log(`Updated cart item ${productId} to quantity ${quantity} for user ${userId}`);
        return res.json(updatedItem);
      } else {
        // Add new cart item
        const newItem = await storage.addToCart({
          userId,
          productId,
          quantity
        });
        console.log(`Added new item to cart: ${productId} with quantity ${quantity} for user ${userId}`);
        return res.json(newItem);
      }
    } catch (error) {
      console.error("Error updating cart:", error);
      res.status(500).json({ message: "Failed to update cart" });
    }
  });

  app.put("/api/cart/:productId", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const productId = parseInt(req.params.productId);
      const { quantity } = req.body;
      
      console.log("Updating cart item for user:", userId, "Product ID:", productId, "Quantity:", quantity);
      
      // Special case for admin user
      if (userId === 'admin-user') {
        console.log("Admin user - simulating update cart success");
        if (quantity <= 0) {
          return res.json({ message: "Item removed from cart" });
        }
        return res.json({
          id: Date.now(),
          userId: 'admin-user',
          productId: productId,
          quantity: quantity,
          createdAt: new Date()
        });
      }
      
      if (typeof quantity !== 'number' || isNaN(quantity)) {
        return res.status(400).json({ message: "Invalid quantity" });
      }
      
      // If quantity is 0 or less, remove from cart
      if (quantity <= 0) {
        await storage.removeFromCart(userId, productId);
        return res.json({ message: "Item removed from cart" });
      }
      
      // Verify the product exists and has enough stock
      const product = await storage.getProductById(productId);
      if (!product) {
        return res.status(404).json({ message: "Product not found" });
      }
      
      if (product.stock < quantity) {
        return res.status(400).json({ message: "Not enough stock available" });
      }
      
      const updatedItem = await storage.updateCartItem(userId, productId, quantity);
      res.json(updatedItem || { message: "Item removed from cart" });
    } catch (error) {
      console.error("Error updating cart:", error);
      res.status(500).json({ message: "Failed to update cart" });
    }
  });

  app.delete("/api/cart/:productId", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const productId = parseInt(req.params.productId);
      
      console.log("Removing from cart for user:", userId, "Product ID:", productId);
      
      // Special case for admin user - update the global admin cart
      if (userId === 'admin-user') {
        console.log("Admin user - removing from global admin cart");
        
        // Find and remove the item from the global admin cart
        const initialLength = globalAdminCart.length;
        globalAdminCart = globalAdminCart.filter(item => item.productId !== productId);
        
        if (globalAdminCart.length < initialLength) {
          console.log(`Successfully removed product ${productId} from admin cart`);
        } else {
          console.log(`Product ${productId} not found in admin cart`);
        }
        
        return res.json({ 
          message: "Item removed from cart", 
          removed: initialLength !== globalAdminCart.length,
          productId
        });
      }
      
      await storage.removeFromCart(userId, productId);
      res.json({ message: "Item removed from cart" });
    } catch (error) {
      console.error("Error removing from cart:", error);
      res.status(500).json({ message: "Failed to remove from cart" });
    }
  });

  app.delete("/api/cart", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      
      console.log("Clearing cart for user:", userId);
      
      // Special case for admin user - actually clear the cart now
      if (userId === 'admin-user') {
        console.log("Admin user - clearing cart");
        // Clear the in-memory cart first
        globalAdminCart = [];
        
        // Then clear from the database for good measure
        try {
          await storage.clearCart('admin-user');
        } catch (storageError) {
          console.log("Note: Storage clear for admin-user failed, but in-memory cart cleared:", storageError);
        }
        
        return res.json({ message: "Admin cart cleared" });
      }
      
      await storage.clearCart(userId);
      res.json({ message: "Cart cleared" });
    } catch (error) {
      console.error("Error clearing cart:", error);
      res.status(500).json({ message: "Failed to clear cart" });
    }
  });

  // Delivery Address routes
  app.get("/api/delivery-addresses", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      
      const addresses = await storage.getDeliveryAddresses(userId);
      res.json(addresses);
    } catch (error) {
      console.error('Error fetching delivery addresses:', error);
      res.status(500).json({ message: 'Error fetching delivery addresses' });
    }
  });
  
  app.get("/api/delivery-addresses/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const addressId = parseInt(req.params.id);
      
      const address = await storage.getDeliveryAddressById(addressId);
      
      if (!address) {
        return res.status(404).json({ message: 'Address not found' });
      }
      
      if (address.userId !== userId) {
        return res.status(403).json({ message: 'Forbidden' });
      }
      
      res.json(address);
    } catch (error) {
      console.error('Error fetching delivery address:', error);
      res.status(500).json({ message: 'Error fetching delivery address' });
    }
  });
  
  app.post("/api/delivery-addresses", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      
      const validationResult = insertDeliveryAddressSchema.safeParse({
        ...req.body,
        userId
      });
      
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: 'Invalid delivery address data',
          errors: validationResult.error.errors
        });
      }
      
      const newAddress = await storage.createDeliveryAddress(validationResult.data);
      res.status(201).json(newAddress);
    } catch (error) {
      console.error('Error creating delivery address:', error);
      res.status(500).json({ message: 'Error creating delivery address' });
    }
  });
  
  app.put("/api/delivery-addresses/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const addressId = parseInt(req.params.id);
      
      // Check if address exists and belongs to this user
      const existingAddress = await storage.getDeliveryAddressById(addressId);
      
      if (!existingAddress) {
        return res.status(404).json({ message: 'Address not found' });
      }
      
      if (existingAddress.userId !== userId) {
        return res.status(403).json({ message: 'Forbidden' });
      }
      
      // Update the address
      const updatedAddress = await storage.updateDeliveryAddress(addressId, req.body);
      res.json(updatedAddress);
    } catch (error) {
      console.error('Error updating delivery address:', error);
      res.status(500).json({ message: 'Error updating delivery address' });
    }
  });
  
  app.delete("/api/delivery-addresses/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const addressId = parseInt(req.params.id);
      
      // Check if address exists and belongs to this user
      const existingAddress = await storage.getDeliveryAddressById(addressId);
      
      if (!existingAddress) {
        return res.status(404).json({ message: 'Address not found' });
      }
      
      if (existingAddress.userId !== userId) {
        return res.status(403).json({ message: 'Forbidden' });
      }
      
      // Delete the address
      await storage.deleteDeliveryAddress(addressId);
      res.status(204).send();
    } catch (error) {
      console.error('Error deleting delivery address:', error);
      res.status(500).json({ message: 'Error deleting delivery address' });
    }
  });
  
  app.post("/api/delivery-addresses/:id/set-default", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const addressId = parseInt(req.params.id);
      
      // Check if address exists and belongs to this user
      const existingAddress = await storage.getDeliveryAddressById(addressId);
      
      if (!existingAddress) {
        return res.status(404).json({ message: 'Address not found' });
      }
      
      if (existingAddress.userId !== userId) {
        return res.status(403).json({ message: 'Forbidden' });
      }
      
      // Set as default
      await storage.setDefaultDeliveryAddress(userId, addressId);
      res.json({ message: 'Default address updated' });
    } catch (error) {
      console.error('Error setting default delivery address:', error);
      res.status(500).json({ message: 'Error setting default delivery address' });
    }
  });
  
  // Staff-specific route to view all customer orders
  app.get("/api/staff/orders", requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      console.log('Staff order listing request received');
      
      // Staff should see all orders
      const allOrders = await storage.getAllOrders();
      
      // Add customer information to each order
      const ordersWithCustomerInfo = await Promise.all(
        allOrders.map(async (order) => {
          const user = await storage.getUser(order.userId);
          return {
            ...order,
            customerName: user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() || user.username : 'Unknown'
          };
        })
      );
      
      res.json(ordersWithCustomerInfo);
    } catch (error) {
      console.error('Error fetching orders for staff:', error);
      res.status(500).json({ message: 'Failed to fetch orders' });
    }
  });
  
  // Staff route to update product image URL
  app.patch("/api/staff/products/:id", requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const productId = parseInt(req.params.id);
      const { imageUrl } = req.body;
      
      console.log(`Staff ${userId} updating product ${productId} image URL to: ${imageUrl}`);
      
      // Validate the imageUrl is provided
      if (!imageUrl) {
        return res.status(400).json({ message: "Image URL is required" });
      }
      
      // Log this activity
      try {
        await storage.addActivityLog({
          userId,
          action: 'UPDATE_PRODUCT_IMAGE',
          details: `Updated image URL for product ID ${productId}`,
          targetId: productId.toString(),
          targetType: 'product',
          timestamp: new Date()
        });
      } catch (logError: any) {
        // Just log the error but don't abort the image update
        console.warn("Could not log activity (this is okay):", logError.message);
      }
      
      // Update the product
      const product = await storage.updateProduct(productId, { imageUrl });
      
      if (!product) {
        return res.status(404).json({ message: "Product not found" });
      }
      
      res.json(product);
    } catch (error) {
      console.error("Error updating product image:", error);
      res.status(500).json({ message: "Failed to update product image" });
    }
  });
  
  // Staff route to update product details (name, description, price, etc.)
  app.put("/api/staff/products/:id", async (req: any, res) => {
    // Extract token directly from headers
    const token = req.headers['x-auth-token'] || req.headers.authorization?.split(' ')[1];
    if (!token) {
      return res.status(401).json({ message: 'No authentication token provided' });
    }

    // Special case for admin tokens (which are in format 'admin-token-{timestamp}')
    if (token.startsWith('admin-token-')) {
      // This is the admin - set default admin user
      req.user = {
        id: 'admin-user',
        username: 'admin',
        isAdmin: true
      };
    } else {
      // Handle regular tokens
      const userId = validateToken(token);
      if (!userId) {
        return res.status(401).json({ message: 'Invalid or expired token' });
      }

      // For regular users, try to find them in the database
      try {
        const user = await storage.getUser(userId);
        if (!user) {
          // Special fallback for admin user if token is valid but user not found in DB
          if (userId === 'admin-user') {
            req.user = {
              id: 'admin-user',
              username: 'admin',
              isAdmin: true
            };
            return; // Continue with processing
          }
          return res.status(401).json({ message: 'User not found' });
        }

        // Check if user is admin or employee
        if (!user.isAdmin && !user.isEmployee) {
          return res.status(403).json({ message: 'Staff access required' });
        }

        // Set req.user for use in the rest of the handler
        req.user = user;
      } catch (error) {
        console.error('Error fetching user:', error);
        return res.status(500).json({ message: 'Internal server error' });
      }
    }
    try {
      const userId = req.user.id;
      const productId = parseInt(req.params.id);
      const productData = req.body;
      
      console.log(`Staff ${userId} updating product ${productId} details:`, productData);
      
      // Convert numeric fields if they're strings
      if (typeof productData.price === 'string') {
        productData.price = parseFloat(productData.price);
      }
      
      if (typeof productData.stock === 'string') {
        productData.stock = parseInt(productData.stock);
      }
      
      // Skip activity logging for now since the table doesn't exist yet
      try {
        // Log this activity if table exists
        await storage.addActivityLog({
          userId,
          action: 'UPDATE_PRODUCT_DETAILS',
          details: `Updated details for product ID ${productId}`,
          targetId: productId.toString(),
          targetType: 'product',
          timestamp: new Date()
        });
      } catch (logError) {
        // Just log the error but don't abort the update
        console.warn("Could not log activity (this is okay):", logError.message);
      }
      
      // Log updated data for debugging
      console.log("Updating product", productId, "with data:", productData);
      
      // Get existing product data for debugging
      const existingProduct = await storage.getProduct(productId);
      console.log("Existing product data:", existingProduct);
      
      // Update the product
      const product = await storage.updateProduct(productId, productData);
      
      if (!product) {
        return res.status(404).json({ message: "Product not found" });
      }
      
      console.log("Update result:", product);
      res.json(product);
    } catch (error) {
      console.error("Error updating product details:", error);
      res.status(500).json({ 
        message: "Failed to update product details",
        error: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  
  // Staff route to delete a product
  app.delete("/api/staff/products/:id", async (req: any, res) => {
    // Extract token from all possible header locations
    let token = null;
    
    // Try Authorization header with Bearer prefix
    if (req.headers.authorization && req.headers.authorization.startsWith('Bearer ')) {
      token = req.headers.authorization.split(' ')[1];
    } 
    // Try plain Authorization header
    else if (req.headers.authorization) {
      token = req.headers.authorization;
    } 
    // Try x-auth-token header
    else if (req.headers['x-auth-token']) {
      token = req.headers['x-auth-token'];
    }
    
    if (!token) {
      return res.status(401).json({ message: 'No authentication token provided' });
    }

    // Special case for admin tokens (which are in format 'admin-token-{timestamp}')
    if (token.startsWith('admin-token-')) {
      // This is the admin - set default admin user
      req.user = {
        id: 'admin-user',
        username: 'admin',
        isAdmin: true
      };
    } else {
      // Handle regular tokens
      const userId = validateToken(token);
      if (!userId) {
        return res.status(401).json({ message: 'Invalid or expired token' });
      }

      // For regular users, try to find them in the database
      try {
        const user = await storage.getUser(userId);
        if (!user) {
          // Special fallback for admin user if token is valid but user not found in DB
          if (userId === 'admin-user') {
            req.user = {
              id: 'admin-user',
              username: 'admin',
              isAdmin: true
            };
            // Continue with processing
          } else {
            return res.status(401).json({ message: 'User not found' });
          }
        } else {
          // Check if user is admin or employee
          if (!user.isAdmin && !user.isEmployee) {
            return res.status(403).json({ message: 'Staff access required' });
          }

          // Set req.user for use in the rest of the handler
          req.user = user;
        }
      } catch (error) {
        console.error('Error fetching user:', error);
        return res.status(500).json({ message: 'Internal server error' });
      }
    }
    
    try {
      const userId = req.user.id;
      const productId = parseInt(req.params.id);
      
      if (isNaN(productId) || productId <= 0) {
        return res.status(400).json({ message: "Invalid product ID" });
      }
      
      console.log(`Staff ${userId} deleting product ${productId}`);
      
      // Try to log this activity
      try {
        await storage.addActivityLog({
          userId,
          action: 'DELETE_PRODUCT',
          details: `Deleted product ID ${productId}`,
          targetId: productId.toString(),
          targetType: 'product',
          timestamp: new Date()
        });
      } catch (logError) {
        // Just log the error but don't abort the deletion
        console.warn("Could not log activity (this is okay):", logError.message);
      }
      
      // First check if product exists
      try {
        const product = await storage.getProductById(productId);
        if (!product) {
          return res.status(404).json({ message: "Product not found" });
        }
      } catch (checkError) {
        console.warn("Error checking if product exists, will try deletion anyway:", checkError);
      }
      
      // Delete the product
      await storage.deleteProduct(productId);
      
      res.json({ success: true, message: "Product deleted successfully" });
    } catch (error) {
      console.error("Error deleting product:", error);
      
      // Handle specific error cases
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      
      if (errorMessage.includes("cart")) {
        return res.status(400).json({ 
          message: "Cannot delete product that is in a cart",
          error: errorMessage
        });
      } else if (errorMessage.includes("ordered")) {
        return res.status(400).json({ 
          message: "Cannot delete product that has been ordered",
          error: errorMessage
        });
      }
      
      res.status(500).json({ 
        message: "Failed to delete product", 
        error: errorMessage
      });
    }
  });
  
  // Orders routes
  app.get("/api/orders", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const isAdmin = req.user.isAdmin === true;
      
      console.log("Fetching orders for user:", userId);
      
      // If admin or special admin-user ID, return all orders
      if (isAdmin || userId === 'admin-user') {
        console.log("Admin user - returning all orders");
        
        try {
          // Try using the regular storage method
          const allOrders = await storage.getAllOrders();
          return res.json(allOrders);
        } catch (storageError) {
          console.log("Error with getAllOrders, using direct DB query:", storageError);
          
          // Get all orders directly from the database with customer information
          const ordersWithItems = await db.execute(sql`
            WITH order_data AS (
              SELECT 
                o.id, 
                o.user_id, 
                o.total, 
                o.order_type, 
                o.status, 
                o.pickup_date, 
                o.pickup_time_slot, 
                o.notes,
                o.created_at,
                o.updated_at,
                u.username, 
                u.first_name, 
                u.last_name,
                u.business_name,
                u.phone,
                u.address,
                u.city,
                u.state,
                u.postal_code
              FROM orders o
              LEFT JOIN users u ON o.user_id = u.id
              ORDER BY o.created_at DESC
            ),
            items_data AS (
              SELECT 
                oi.order_id,
                json_agg(
                  json_build_object(
                    'id', oi.id,
                    'productId', oi.product_id,
                    'quantity', oi.quantity,
                    'price', oi.price,
                    'product', json_build_object(
                      'id', p.id,
                      'name', p.name,
                      'imageUrl', p.image_url,
                      'price', p.price
                    )
                  )
                ) as items
              FROM order_items oi
              LEFT JOIN products p ON oi.product_id = p.id
              GROUP BY oi.order_id
            )
            SELECT 
              od.id, 
              od.user_id as "userId", 
              od.total, 
              od.order_type as "orderType", 
              od.status, 
              od.pickup_date as "pickupDate", 
              od.pickup_time_slot as "pickupTimeSlot", 
              od.notes,
              od.created_at as "createdAt",
              od.updated_at as "updatedAt",
              json_build_object(
                'id', od.user_id,
                'username', od.username,
                'firstName', od.first_name,
                'lastName', od.last_name,
                'businessName', od.business_name,
                'phone', od.phone,
                'address', od.address,
                'city', od.city,
                'state', od.state,
                'postalCode', od.postal_code
              ) as customer,
              COALESCE(id.items, '[]'::json) as items
            FROM order_data od
            LEFT JOIN items_data id ON od.id = id.order_id
          `);
          
          // Convert raw query result to an array of orders to maintain consistency
          const formattedOrders = Array.isArray(ordersWithItems) 
            ? ordersWithItems 
            : (ordersWithItems.rows || []);
            
          return res.json(formattedOrders);
        }
      }
      
      const orders = await storage.getOrdersByUser(userId);
      res.json(orders);
    } catch (error) {
      console.error("Error fetching orders:", error);
      res.status(500).json({ message: "Failed to fetch orders" });
    }
  });
  
  // Update order status endpoint
  app.patch("/api/orders/:id/status", async (req: any, res) => {
    // Extract token directly from headers
    const token = req.headers['x-auth-token'] || req.headers.authorization?.split(' ')[1];
    if (!token) {
      return res.status(401).json({ message: 'No authentication token provided' });
    }

    // Special case for admin tokens (which are in format 'admin-token-{timestamp}')
    if (token.startsWith('admin-token-')) {
      // This is the admin - set default admin user
      req.user = {
        id: 'admin-user',
        username: 'admin',
        isAdmin: true
      };
    } else {
      // Handle regular tokens
      const userId = validateToken(token);
      if (!userId) {
        return res.status(401).json({ message: 'Invalid or expired token' });
      }

      // For regular users, try to find them in the database
      try {
        const user = await storage.getUser(userId);
        if (!user) {
          // Special fallback for admin user if token is valid but user not found in DB
          if (userId === 'admin-user') {
            req.user = {
              id: 'admin-user',
              username: 'admin',
              isAdmin: true
            };
            // Continue with processing
          } else {
            return res.status(401).json({ message: 'User not found' });
          }
        } else {
          // Check if user is admin or employee
          if (!user.isAdmin && !user.isEmployee) {
            return res.status(403).json({ message: 'Staff access required' });
          }

          // Set req.user for use in the rest of the handler
          req.user = user;
        }
      } catch (error) {
        console.error('Error fetching user:', error);
        return res.status(500).json({ message: 'Internal server error' });
      }
    }
    try {
      const orderId = parseInt(req.params.id);
      const { status } = req.body;
      const userId = req.user.id;
      const isAdmin = req.user.isAdmin === true;
      
      // Staff (employees and admins) can update order status
      // No permission check needed here since we're using requireEmployeeOrAdmin middleware
      
      if (isNaN(orderId)) {
        return res.status(400).json({ message: "Invalid order ID" });
      }
      
      if (!status || !['pending', 'processing', 'ready', 'completed', 'cancelled'].includes(status)) {
        return res.status(400).json({ message: "Invalid status" });
      }
      
      console.log(`Updating order ${orderId} status to ${status}`);
      
      try {
        // Try using storage method
        const updatedOrder = await storage.updateOrderStatus(orderId, status);
        return res.json(updatedOrder);
      } catch (storageError) {
        console.log("Error using storage.updateOrderStatus, using direct query:", storageError);
        
        // Update directly in the database
        const result = await db.execute(
          sql`UPDATE orders SET status = ${status}, updated_at = NOW() WHERE id = ${orderId} RETURNING *`
        );
        
        const rows = result.rows;
        if (!rows || rows.length === 0) {
          return res.status(404).json({ message: "Order not found" });
        }
        
        return res.json(rows[0]);
      }
    } catch (error) {
      console.error("Error updating order status:", error);
      res.status(500).json({ message: "Failed to update order status" });
    }
  });

  app.get("/api/orders/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      
      // Make sure order ID is a valid number
      let orderId;
      try {
        orderId = parseInt(req.params.id);
        if (isNaN(orderId)) {
          return res.status(400).json({ message: "Invalid order ID" });
        }
      } catch (error) {
        console.error("Error parsing order ID:", req.params.id);
        return res.status(400).json({ message: "Invalid order ID format" });
      }
      
      console.log("Fetching order details for user:", userId, "Order ID:", orderId);
      
      // Special handling for hardcoded admin
      if (userId === 'admin-user') {
        console.log('Hardcoded admin user accessing order details');
        const order = await storage.getOrderById(orderId);
        
        if (!order) {
          return res.status(404).json({ message: "Order not found" });
        }
        
        console.log('Order found for admin access:', `Order #${orderId}`);
        return res.json(order);
      }
      
      // For database users, check admin and employee status for permission to view any order
      const user = await storage.getUser(userId);
      const isAdmin = user?.isAdmin === true;
      const isEmployee = user?.isEmployee === true;
      const isStaff = isAdmin || isEmployee;
      
      // Log permissions for debugging
      console.log('User permissions:', { isAdmin, isEmployee, isStaff, userId });
      
      const order = await storage.getOrderById(orderId);
      
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }
      
      console.log('Order fetch result:', `Order #${orderId} found`);
      
      // Staff users (admin and employees) can view any order, regular users can only view their own
      if (!isStaff && order.userId !== userId) {
        console.log('Unauthorized access - user trying to view someone else\'s order');
        return res.status(403).json({ message: "Unauthorized" });
      }
      
      res.json(order);
    } catch (error) {
      console.error("Error fetching order:", error);
      res.status(500).json({ message: "Failed to fetch order" });
    }
  });

  app.post("/api/orders", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      
      console.log("Creating order for user:", userId);
      
      // Special case for admin user
      if (userId === 'admin-user') {
        console.log("Admin user - simulating order creation success");
        return res.status(201).json({
          id: Date.now(),
          userId: 'admin-user',
          status: 'pending',
          total: req.body.total || 0,
          deliveryDate: req.body.deliveryDate,
          deliveryTimeSlot: req.body.deliveryTimeSlot,
          createdAt: new Date()
        });
      }
      
      // Get the user's cart first
      const cartItems = await storage.getCartItems(userId);
      
      if (cartItems.length === 0) {
        return res.status(400).json({ message: "Cart is empty" });
      }
      
      // Validate the order data
      const { deliveryDate, deliveryTimeSlot } = req.body;
      
      // Calculate total from cart items
      const total = cartItems.reduce((sum, item) => {
        return sum + (item.quantity * item.product.price);
      }, 0);
      
      const orderData = insertOrderSchema.parse({
        userId,
        total,
        deliveryDate,
        deliveryTimeSlot,
        status: "processing"
      });
      
      // Create order items from cart items
      const orderItems = cartItems.map(item => ({
        productId: item.productId,
        quantity: item.quantity,
        price: item.product.price
      }));
      
      // Create the order with its items
      const order = await storage.createOrder(orderData, orderItems);
      
      // Update product stock for each item
      for (const item of cartItems) {
        await storage.updateProductStock(item.productId, -item.quantity);
      }
      
      res.status(201).json(order);
    } catch (error) {
      console.error("Error creating order:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid order data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create order" });
    }
  });

  // Public route for updating order status (accessible to both admin and customers)
  app.put("/api/orders/:id/status", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      // Add more debugging
      console.log(`Status update requested by user: ${userId}`);
      console.log(`Request body:`, req.body);
      
      const user = await storage.getUser(userId);
      const orderId = parseInt(req.params.id);
      const { status } = req.body;
      
      // Validate request
      if (!status) {
        console.log("Status missing in request");
        return res.status(400).json({ message: "Status is required" });
      }
      
      // Get the order to verify ownership
      const order = await storage.getOrderById(orderId);
      
      if (!order) {
        console.log(`Order #${orderId} not found for status update`);
        return res.status(404).json({ message: "Order not found" });
      }
      
      const isAdmin = user?.isAdmin || userId === 'admin-user';
      const isOrderOwner = order.userId === userId;
      
      console.log(`User permissions for order status update:`, {
        userId,
        isAdmin,
        isOrderOwner,
        requestedStatus: status,
        orderId
      });
      
      // Allow admin to update status (any status)
      if (isAdmin) {
        console.log(`Admin user (${userId}) updating order #${orderId} status to ${status}`);
        
        // Update the order status
        const updatedOrder = await storage.updateOrderStatus(orderId, status);
        
        console.log(`Successfully updated order #${orderId} status to ${status}`);
        
        // Return the updated order
        return res.json({
          success: true,
          order: updatedOrder,
          message: `Order status updated to ${status}`
        });
      } 
      // Allow customers to mark their own orders as completed or cancelled
      else if (isOrderOwner && (status === 'completed' || status === 'cancelled')) {
        console.log(`Customer (${userId}) marking their order #${orderId} as ${status}`);
        
        // Update the order status
        const updatedOrder = await storage.updateOrderStatus(orderId, status);
        
        console.log(`Successfully updated order #${orderId} status to ${status}`);
        
        // Return the updated order
        return res.json({
          success: true,
          order: updatedOrder,
          message: `Order status updated to ${status}`
        });
      } 
      // Deny other status update requests
      else {
        console.log(`Unauthorized status update by user (${userId}) to status ${status}`);
        return res.status(403).json({ 
          message: isOrderOwner 
            ? "As a customer, you can only mark orders as completed or cancelled" 
            : "Unauthorized - You can only update your own orders"
        });
      }
    } catch (error) {
      console.error("Error updating order status:", error);
      res.status(500).json({ message: "Failed to update order status" });
    }
  });

  // Add admin note to order (legacy route)
  app.put("/api/orders/:id/note", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      const orderId = parseInt(req.params.id);
      const { adminNote } = req.body;
      
      // Only admin can add notes
      if (!user?.isAdmin) {
        return res.status(403).json({ message: "Unauthorized - Only admins can add notes" });
      }
      
      // Get the order
      const order = await storage.getOrderById(orderId);
      
      // If order not found
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }
      
      // Update order with note
      const updatedOrder = await storage.updateOrder(orderId, { adminNote });
      
      // Return the updated order
      res.json({ 
        success: true, 
        order: updatedOrder,
        message: "Admin note updated"
      });
    } catch (error) {
      console.error("Error updating admin note:", error);
      res.status(500).json({ message: "Failed to update admin note" });
    }
  });
  
  // Admin route - update order with admin note
  app.put("/api/admin/orders/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      const orderId = parseInt(req.params.id);
      const { adminNote } = req.body;
      
      // Only admin can update orders
      if (!user?.isAdmin) {
        return res.status(403).json({ message: "Unauthorized - Admin access required" });
      }
      
      // Get the order
      const order = await storage.getOrderById(orderId);
      
      // If order not found
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }
      
      // Make sure adminNote is provided
      if (typeof adminNote !== 'string') {
        return res.status(400).json({ message: "Admin note is required" });
      }
      
      // Update order with admin note
      const updatedOrder = await storage.updateOrder(orderId, { adminNote });
      
      // Return the updated order
      res.json({ 
        success: true, 
        order: updatedOrder,
        message: "Order updated successfully"
      });
    } catch (error) {
      console.error("Error updating order:", error);
      res.status(500).json({ message: "Failed to update order" });
    }
  });
  
  // Get all orders for admin
  app.get("/api/admin/orders", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      
      // Only admin can view all orders
      if (!user?.isAdmin) {
        return res.status(403).json({ message: "Unauthorized" });
      }
      
      // Get all orders
      const orders = await storage.getAllOrders();
      
      res.json(orders);
    } catch (error) {
      console.error("Error fetching all orders:", error);
      res.status(500).json({ message: "Failed to fetch orders" });
    }
  });
  
  // Admin route - get specific order details
  app.get("/api/admin/orders/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      
      // Only admin can view any order details
      if (!user?.isAdmin) {
        return res.status(403).json({ message: "Unauthorized" });
      }
      
      // Make sure order ID is a valid number
      let orderId;
      try {
        orderId = parseInt(req.params.id);
        if (isNaN(orderId) || orderId <= 0) {
          console.error("Invalid order ID:", req.params.id);
          return res.status(400).json({ message: "Invalid order ID" });
        }
      } catch (error) {
        console.error("Error parsing order ID:", req.params.id, error);
        return res.status(400).json({ message: "Invalid order ID format" });
      }
      
      console.log("Admin fetching order details for ID:", orderId);
      
      // Get order details with all related information
      const order = await storage.getOrderById(orderId);
      
      if (!order) {
        console.log("Order not found:", orderId);
        return res.status(404).json({ message: "Order not found" });
      }
      
      console.log("Returning order details:", order.id);
      res.json(order);
    } catch (error) {
      console.error("Error fetching order details:", error);
      res.status(500).json({ message: "Failed to fetch order details" });
    }
  });
  
  // Admin routes - update order status
  app.put("/api/admin/orders/:id/status", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      
      if (!user?.isAdmin) {
        return res.status(403).json({ message: "Unauthorized" });
      }
      
      const orderId = parseInt(req.params.id);
      const { status } = req.body;
      
      if (!status) {
        return res.status(400).json({ message: "Status is required" });
      }
      
      const updatedOrder = await storage.updateOrderStatus(orderId, status);
      
      if (!updatedOrder) {
        return res.status(404).json({ message: "Order not found" });
      }
      
      res.json(updatedOrder);
    } catch (error) {
      console.error("Error updating order status:", error);
      res.status(500).json({ message: "Failed to update order status" });
    }
  });
  
  // Admin routes - user management
  app.get("/api/admin/users", requireAdmin, async (req: any, res) => {
    try {
      
      const users = await storage.getAllUsers();
      res.json(users);
    } catch (error) {
      console.error("Error fetching users:", error);
      res.status(500).json({ message: "Failed to fetch users" });
    }
  });
  
  // Create a new customer account (admin only)
  app.post("/api/admin/users", requireAdmin, async (req: any, res) => {
    try {
      console.log("Admin user creation request received");
      
      const { 
        // Account information
        username, 
        firstName, 
        lastName, 
        password,
        // Business details 
        company,
        // Address information
        address,
        // Customer level for pricing
        customerLevel,
        // Admin access
        isAdmin
      } = req.body;
      
      console.log("Creating user with username:", username);
      
      if (!username || !password) {
        return res.status(400).json({ message: "Username and password are required" });
      }
      
      try {
        // Check if the user already exists
        const existingUser = await storage.getUserByUsername(username);
        if (existingUser) {
          return res.status(400).json({ message: "Username is already taken" });
        }
      } catch (userCheckError) {
        console.log("Error checking for existing user:", userCheckError);
        // Continue anyway - better to attempt creation than to block due to DB errors
      }
      
      // Generate a random ID for the customer (since we're not using Replit Auth for them)
      const customerId = `cust_${Math.random().toString(36).substring(2, 15)}`;
      
      try {
        // Create the user with a hashed password and all the additional fields
        const user = await storage.createCustomerUser({
          id: customerId,
          username,
          firstName,
          lastName,
          company,
          address,
          customerLevel: customerLevel || 1,
          password,
          isAdmin: isAdmin || false
        });
        
        console.log("User created successfully:", user.id);
        
        // Return the created user (with sensitive information filtered out)
        return res.status(201).json({
          id: user.id,
          username: user.username,
          firstName: user.firstName,
          lastName: user.lastName,
          company: user.company,
          address: user.address,
          customerLevel: user.customerLevel,
          isAdmin: user.isAdmin,
          createdAt: user.createdAt
        });
      } catch (createError) {
        console.error("Error creating user in database:", createError);
        return res.status(500).json({ message: "Database error during user creation", error: createError.message });
      }
    } catch (error) {
      console.error("Error creating user:", error);
      res.status(500).json({ message: "Failed to create user" });
    }
  });
  
  // Update a user (admin only)
  app.put("/api/admin/users/:id", requireAuth, async (req: any, res) => {
    try {
      const adminId = req.user.id;
      const admin = await storage.getUser(adminId);
      
      if (!admin?.isAdmin) {
        return res.status(403).json({ message: "Unauthorized" });
      }
      
      const userId = req.params.id;
      const { email, firstName, lastName, company, password } = req.body;
      
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const updatedUser = await storage.updateUser({
        id: userId,
        email: email || user.email,
        firstName: firstName || user.firstName,
        lastName: lastName || user.lastName,
        company: company || user.company,
        password: password || undefined,
        isAdmin: user.isAdmin
      });
      
      res.json({
        id: updatedUser.id,
        email: updatedUser.email,
        firstName: updatedUser.firstName,
        lastName: updatedUser.lastName,
        company: updatedUser.company,
        isAdmin: updatedUser.isAdmin,
        updatedAt: updatedUser.updatedAt
      });
    } catch (error) {
      console.error("Error updating user:", error);
      res.status(500).json({ message: "Failed to update user" });
    }
  });
  
  // Delete a user (admin only)
  app.delete("/api/admin/users/:id", requireAuth, async (req: any, res) => {
    try {
      const adminId = req.user.id;
      
      // Special handling for hardcoded admin
      if (adminId === 'admin-user') {
        console.log('Hardcoded admin user deleting a user');
        const userId = req.params.id;
        
        // Don't allow deleting self
        if (userId === adminId) {
          return res.status(400).json({ message: "Cannot delete your own account" });
        }
        
        // Log this activity
        await storage.addActivityLog({
          userId: adminId,
          action: 'DELETE_USER',
          details: `Admin deleted user ${userId}`,
          timestamp: new Date()
        });
        
        await storage.deleteUser(userId);
        return res.json({ message: "User deleted successfully" });
      }
      
      // For database users, check admin status
      const admin = await storage.getUser(adminId);
      
      if (!admin?.isAdmin) {
        return res.status(403).json({ message: "Unauthorized" });
      }
      
      const userId = req.params.id;
      
      // Don't allow deleting self
      if (userId === adminId) {
        return res.status(400).json({ message: "Cannot delete your own account" });
      }
      
      // Log this activity
      await storage.addActivityLog({
        userId: adminId,
        action: 'DELETE_USER',
        details: `Admin ${admin.username} deleted user ${userId}`,
        timestamp: new Date()
      });
      
      await storage.deleteUser(userId);
      res.json({ message: "User deleted successfully" });
    } catch (error) {
      console.error("Error deleting user:", error);
      res.status(500).json({ message: "Failed to delete user" });
    }
  });
  
  // Get orders for a specific user (admin only)
  app.get("/api/admin/users/:userId/orders", requireAuth, async (req: any, res) => {
    try {
      const adminId = req.user.id;
      const admin = await storage.getUser(adminId);
      
      if (!admin?.isAdmin) {
        return res.status(403).json({ message: "Unauthorized" });
      }
      
      const { userId } = req.params;
      
      // Fetch orders for the specific user
      const orders = await storage.getOrdersByUserId(userId);
      
      // For each order, fetch its items
      const ordersWithItems = await Promise.all(
        orders.map(async (order) => {
          const items = await storage.getOrderItems(order.id);
          
          // Fetch product names for display
          const itemsWithProductNames = await Promise.all(
            items.map(async (item) => {
              const product = await storage.getProduct(item.productId);
              return {
                ...item,
                productName: product ? product.name : 'Unknown Product'
              };
            })
          );
          
          return {
            ...order,
            items: itemsWithProductNames
          };
        })
      );
      
      res.json(ordersWithItems);
    } catch (error) {
      console.error('Error fetching user orders:', error);
      res.status(500).json({ message: 'Failed to fetch user orders' });
    }
  });
  
  // Get activity logs (admin only)
  app.get("/api/admin/activity-logs", requireAuth, async (req: any, res) => {
    try {
      const adminId = req.user.id;
      
      // Special handling for hardcoded admin
      if (adminId === 'admin-user') {
        console.log('Hardcoded admin user accessing activity logs');
        const logs = await storage.getActivityLogs();
        
        // Enrich logs with user information
        const logsWithUserDetails = await Promise.all(
          logs.map(async (log) => {
            const user = await storage.getUser(log.userId);
            return {
              ...log,
              username: user ? user.username : 'Unknown',
              fullName: user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() : ''
            };
          })
        );
        
        return res.json(logsWithUserDetails);
      }
      
      // For database users, check admin status
      const admin = await storage.getUser(adminId);
      
      if (!admin?.isAdmin) {
        return res.status(403).json({ message: "Unauthorized" });
      }
      
      const logs = await storage.getActivityLogs();
      
      // Enrich logs with user information
      const logsWithUserDetails = await Promise.all(
        logs.map(async (log) => {
          const user = await storage.getUser(log.userId);
          return {
            ...log,
            username: user ? user.username : 'Unknown',
            fullName: user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() : ''
          };
        })
      );
      
      res.json(logsWithUserDetails);
    } catch (error) {
      console.error('Error fetching activity logs:', error);
      res.status(500).json({ message: 'Failed to fetch activity logs' });
    }
  });
  
  // Customer logout route
  app.post("/api/customer/logout", (req, res) => {
    try {
      console.log("Logout request received");
      
      // Clear the auth token cookie
      res.clearCookie('authToken');
      
      // Return success
      res.json({ success: true, message: "Logged out successfully" });
    } catch (error) {
      console.error("Error during logout:", error);
      res.status(500).json({ message: "An error occurred during logout" });
    }
  });
  
  // Simple customer login route with enhanced debug logging
  app.post("/api/customer/login", async (req, res) => {
    try {
      console.log("Login request received:", req.body);
      
      // Make sure we have username and password
      const { username, password } = req.body;
      
      console.log("LOGIN ATTEMPT for username:", username);
      
      if (!username || !password) {
        console.log("Missing username or password");
        return res.status(400).json({ message: "Username and password required" });
      }
      
      console.log("Authenticating user:", username);
      
      // For testing purposes, hardcode admin login
      if (username === 'admin' && password === 'admin123') {
        console.log("Admin login successful");
        
        // Create an auth token 
        const token = "admin-token-" + Date.now();
        
        // Set the token as a cookie that expires in 24 hours
        res.cookie('authToken', token, {
          httpOnly: true,
          secure: false, // Set to false for development
          maxAge: 24 * 60 * 60 * 1000,
          sameSite: 'lax'
        });
        
        // Return response with token and user info
        return res.json({
          token,
          user: {
            id: "admin-user",
            username: "admin",
            customerLevel: 5,
            isAdmin: true
          }
        });
      }
      
      // For normal users, authenticate against database
      const user = await storage.authenticateCustomer(username, password);
      
      if (!user) {
        console.log("Authentication failed for:", username);
        return res.status(401).json({ message: "Invalid username or password" });
      }
      
      console.log("User authenticated successfully:", user.id);
      
      // Create an auth token
      const token = createAuthToken(user.id);
      
      // Set the token as a cookie that expires in 24 hours
      res.cookie('authToken', token, {
        httpOnly: true,
        secure: false, // Set to false for development
        maxAge: 24 * 60 * 60 * 1000,
        sameSite: 'lax'
      });
      
      // Also return it in the response body for clients that prefer tokens
      res.json({
        token,
        user: {
          id: user.id,
          username: user.username,
          customerLevel: user.customerLevel || 0,
          isAdmin: user.isAdmin || false
        }
      });
    } catch (error) {
      console.error("Error during login:", error);
      res.status(500).json({ message: "An error occurred during login. Please try again." });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}

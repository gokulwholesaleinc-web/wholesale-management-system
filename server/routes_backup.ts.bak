import express, { type Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { z } from "zod";
import {
  insertCartItemSchema,
  insertOrderSchema,
  insertOrderItemSchema,
  insertDeliveryAddressSchema,
} from "@shared/schema";
import { db } from "./db";
import multer from "multer";
import path from "path";
import fs from "fs";
import { sql, eq } from "drizzle-orm";
import cookieParser from "cookie-parser";
import { requireAuth, requireAdmin, requireEmployeeOrAdmin, createAuthToken, validateToken } from "./simpleAuth";
import { NotificationService } from "./notification-service";
import { pushNotificationService } from "./pushNotificationService";

// Helper function to calculate delivery fee based on order total
async function calculateDeliveryFee(orderTotal: number): Promise<number> {
  try {
    const settings = await storage.getOrderSettings();
    const freeDeliveryThreshold = settings?.freeDeliveryThreshold || 500;
    const deliveryFee = settings?.deliveryFee || 25;

    return orderTotal >= freeDeliveryThreshold ? 0 : deliveryFee;
  } catch (error) {
    console.error('Error calculating delivery fee:', error);
    // Fallback to default values
    return orderTotal >= 500 ? 0 : 25;
  }
}

export async function registerRoutes(app: Express): Promise<Server> {
  // Essential middleware setup
  app.use(express.json());
  app.use(express.urlencoded({ extended: true }));
  app.use(cookieParser());

  // Serve static files
  app.use('/images', express.static(path.join(process.cwd(), 'public/images')));
  app.use('/uploads', express.static(path.join(process.cwd(), 'public/uploads')));
  app.use('/assets', express.static(path.join(process.cwd(), 'public/assets')));

  // Configure multer for image uploads
  const multerStorage = multer.diskStorage({
    destination: (req, file, cb) => {
      const uploadDir = path.join(process.cwd(), 'public/uploads');
      if (!fs.existsSync(uploadDir)) {
        fs.mkdirSync(uploadDir, { recursive: true });
      }
      cb(null, uploadDir);
    },
    filename: (req, file, cb) => {
      const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
      cb(null, uniqueSuffix + path.extname(file.originalname));
    }
  });

  const upload = multer({ 
    storage: multerStorage,
    limits: { fileSize: 5 * 1024 * 1024 }, // 5MB limit
    fileFilter: (req, file, cb) => {
      const allowedTypes = /jpeg|jpg|png|gif|webp/;
      const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
      const mimetype = allowedTypes.test(file.mimetype);

      if (mimetype && extname) {
        return cb(null, true);
      } else {
        cb(new Error('Only image files are allowed'));
      }
    }
  });

  // CORS headers
  app.use((req, res, next) => {
    res.header('Access-Control-Allow-Origin', '*');
    res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS, PATCH');
    res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization, x-auth-token, auth-token, Authentication, X-Access-Token, token');

    if (req.method === 'OPTIONS') {
      return res.sendStatus(200);
    }
    next();
  });

  // Set JSON content type for all API routes
  app.use('/api', (req, res, next) => {
    res.setHeader('Content-Type', 'application/json');
    next();
  });

  // ============================================================================
  // HEALTH & STATUS ENDPOINTS
  // ============================================================================

  // Health check endpoint
  app.get('/api/health', async (req, res) => {
    res.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      version: '1.0.0'
    });
  });

  // System status endpoint
  app.get('/api/status', async (req, res) => {
    try {
      // Test database connection with basic query
      const result = await db.execute(sql`SELECT 1 as test`);
      res.json({
        status: 'operational',
        database: 'connected',
        timestamp: new Date().toISOString(),
        services: {
          api: 'running',
          database: 'connected',
          authentication: 'active'
        }
      });
    } catch (error) {
      res.status(503).json({
        status: 'degraded',
        database: 'error',
        timestamp: new Date().toISOString(),
        error: 'Database connection failed'
      });
    }
  });

  // ============================================================================
  // AUTHENTICATION ENDPOINTS
  // ============================================================================

  // CONSOLIDATED LOGIN - Use /api/login for all authentication

  app.post('/api/login', async (req, res) => {
    try {
      const { username, password } = req.body;

      if (!username || !password) {
        return res.status(400).json({ 
          success: false,
          message: 'Username and password are required' 
        });
      }

      const user = await storage.authenticateUser(username, password);

      if (!user) {
        return res.status(401).json({ 
          success: false,
          message: 'Incorrect username or password. Please try again.' 
        });
      }

      const token = createAuthToken(user.id);

      res.json({
        success: true,
        token,
        user: {
          id: user.id,
          username: user.username,
          firstName: user.firstName,
          lastName: user.lastName,
          isAdmin: user.isAdmin,
          isEmployee: user.isEmployee,
          customerLevel: user.customerLevel
        }
      });
    } catch (error: any) {
      console.error('Login error:', error);

      // Handle specific authentication errors
      if (error.message === 'USER_NOT_FOUND') {
        return res.status(401).json({ 
          success: false,
          message: 'User not found. Please check your username.' 
        });
      }

      if (error.message === 'INCORRECT_PASSWORD') {
        return res.status(401).json({ 
          success: false,
          message: 'Incorrect password. Please try again.' 
        });
      }

      if (error.message === 'NO_PASSWORD_SET') {
        return res.status(401).json({ 
          success: false,
          message: 'Account has no password set. Please contact support.' 
        });
      }

      // Generic error for other cases
      res.status(500).json({ 
        success: false,
        message: 'An error occurred during login' 
      });
    }
  });

  // ============================================================================
  // AUTHENTICATION ENDPOINTS
  // ============================================================================

  // Get current authenticated user
  app.get('/api/auth/user', requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      res.json(user);
    } catch (error) {
      console.error("Error fetching user:", error);
      res.status(500).json({ message: "Failed to fetch user" });
    }
  });

  // ============================================================================
  // USER MANAGEMENT ENDPOINTS
  // ============================================================================

  app.get('/api/users', requireAdmin, async (req: any, res) => {
    try {
      const users = await storage.getAllUsers();
      res.json(users);
    } catch (error) {
      console.error('Error fetching users:', error);
      res.status(500).json({ message: 'Failed to fetch users' });
    }
  });



  // Staff management endpoint
  app.get('/api/admin/staff', requireAdmin, async (req: any, res) => {
    try {
      const users = await storage.getAllUsers();
      // Filter for staff members only (admins and employees)
      const staff = users.filter(user => user.isAdmin || user.isEmployee);
      res.json(staff);
    } catch (error) {
      console.error('Error fetching staff:', error);
      res.status(500).json({ message: 'Failed to fetch staff' });
    }
  });

  // Create staff member endpoint - MISSING ENDPOINT ADDED
  app.post('/api/admin/staff', requireAdmin, async (req: any, res) => {
    try {
      console.log('[POST /api/admin/staff] Creating staff member:', req.user?.username);
      const staffData = {
        ...req.body,
        isEmployee: true, // Force employee status for staff creation
        isAdmin: req.body.isAdmin || false
      };

      const newStaff = await storage.createUser(staffData);

      // Log staff creation activity
      await storage.addActivityLog({
        userId: req.user.id,
        username: req.user.username,
        action: 'STAFF_CREATED',
        details: `Created new staff member "${newStaff.username}" (ID: ${newStaff.id})`,
        timestamp: new Date(),
        targetId: newStaff.id,
        targetType: 'user'
      });

      res.status(201).json(newStaff);
    } catch (error) {
      console.error('[POST /api/admin/staff] Error creating staff:', error);
      res.status(500).json({ message: 'Failed to create staff member: ' + error.message });
    }
  });

  // Delete staff member endpoint - MISSING ENDPOINT ADDED
  app.delete('/api/admin/staff/:userId', requireAdmin, async (req: any, res) => {
    try {
      const { userId } = req.params;
      console.log('[DELETE /api/admin/staff] Deleting staff member:', userId);

      // Get staff details before deletion for logging
      const staffToDelete = await storage.getUser(userId);
      const staffName = staffToDelete?.username || 'Unknown Staff';

      await storage.deleteUser(userId);

      // Log staff deletion activity
      await storage.addActivityLog({
        userId: req.user.id,
        username: req.user.username,
        action: 'STAFF_DELETED',
        details: `Deleted staff member "${staffName}" (ID: ${userId})`,
        timestamp: new Date(),
        targetId: userId,
        targetType: 'user'
      });

      res.json({ message: 'Staff member deleted successfully' });
    } catch (error) {
      console.error('[DELETE /api/admin/staff] Error deleting staff:', error);
      res.status(500).json({ message: 'Failed to delete staff member: ' + error.message });
    }
  });

  // ============================================================================
  // ADMIN USER MANAGEMENT ENDPOINTS (CONSOLIDATED - NO DUPLICATES)
  // ============================================================================

  // Get all users for admin management
  app.get('/api/admin/users', requireAdmin, async (req: any, res) => {
    try {
      console.log('[GET /api/admin/users] Admin user fetching all users:', req.user?.username);
      const users = await storage.getAllUsers();
      console.log('[GET /api/admin/users] Found', users.length, 'users');
      res.json(users);
    } catch (error) {
      console.error('[GET /api/admin/users] Error fetching users:', error);
      res.status(500).json({ message: 'Failed to fetch users' });
    }
  });

  // Update user endpoint (PATCH)
  app.patch('/api/admin/users/:id', requireAdmin, async (req: any, res) => {
    try {
      console.log('[PATCH /api/admin/users/:id] Admin updating user:', req.params.id);
      const { id } = req.params;
      const updatedUser = await storage.updateUser({ id, ...req.body });

      // Log user update activity
      await storage.addActivityLog({
        userId: req.user.id,
        username: req.user.username,
        action: 'USER_UPDATED',
        details: `Updated user "${updatedUser.username}" (ID: ${id})`,
        timestamp: new Date(),
        targetId: id,
        targetType: 'user'
      });

      res.json(updatedUser);
    } catch (error) {
      console.error('[PATCH /api/admin/users/:id] Error updating user:', error);
      res.status(500).json({ message: 'Failed to update user' });
    }
  });

  // Update user endpoint (PUT for compatibility)
  app.put('/api/admin/users/:id', requireAdmin, async (req: any, res) => {
    try {
      console.log('[PUT /api/admin/users/:id] Admin updating user (PUT):', req.params.id);
      const { id } = req.params;
      const updatedUser = await storage.updateUser({ id, ...req.body });

      // Log user update activity
      await storage.addActivityLog({
        userId: req.user.id,
        username: req.user.username,
        action: 'USER_UPDATED',
        details: `Updated user "${updatedUser.username}" (ID: ${id}) via PUT`,
        timestamp: new Date(),
        targetId: id,
        targetType: 'user'
      });

      res.json(updatedUser);
    } catch (error) {
      console.error('[PUT /api/admin/users/:id] Error updating user:', error);
      res.status(500).json({ message: 'Failed to update user' });
    }
  });

  // Customers endpoint for staff order creation
  app.get('/api/admin/customers', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const customers = await storage.getAllCustomers();
      res.json(customers);
    } catch (error) {
      console.error('Error fetching customers:', error);
      res.status(500).json({ message: 'Failed to fetch customers' });
    }
  });

  // Create new admin/staff user
  app.post('/api/admin/users', requireAdmin, async (req: any, res) => {
    try {
      console.log('[POST /api/admin/users] User creating new user:', req.user?.username, 'Admin status:', req.user?.isAdmin);
      console.log('[POST /api/admin/users] Request body:', req.body);

      const userData = req.body;

      // Validate required fields
      if (!userData.username || !userData.password) {
        return res.status(400).json({ message: 'Username and password are required' });
      }

      const newUser = await storage.createUser(userData);

      // Log user creation activity
      await storage.addActivityLog({
        userId: req.user.id,
        username: req.user.username,
        action: 'USER_CREATED',
        details: `Created new ${userData.isAdmin ? 'admin' : userData.isEmployee ? 'employee' : 'customer'} user "${userData.username}" (ID: ${newUser.id})`,
        timestamp: new Date(),
        targetId: newUser.id,
        targetType: 'user'
      });

      console.log('[POST /api/admin/users] Successfully created user:', newUser.username);
      res.status(201).json(newUser);
    } catch (error) {
      console.error('[POST /api/admin/users] Error creating user:', error);
      res.status(500).json({ message: 'Failed to create user: ' + error.message });
    }
  });

  // Reset user password endpoint - MISSING ENDPOINT ADDED
  app.post('/api/admin/users/:id/reset-password', requireAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { password } = req.body;

      if (!password) {
        return res.status(400).json({ message: 'New password is required' });
      }

      // Get user details for logging
      const user = await storage.getUser(id);
      if (!user) {
        return res.status(404).json({ message: 'User not found' });
      }

      // Update user password
      const updatedUser = await storage.updateUserPassword(id, password);

      // Log password reset activity
      await storage.addActivityLog({
        userId: req.user.id,
        username: req.user.username,
        action: 'USER_PASSWORD_RESET',
        details: `Reset password for user "${user.username}" (ID: ${id})`,
        timestamp: new Date(),
        targetId: id,
        targetType: 'user'
      });

      res.json({ message: 'Password reset successfully' });
    } catch (error) {
      console.error('Error resetting user password:', error);
      res.status(500).json({ message: 'Failed to reset password: ' + error.message });
    }
  });

  // Delete user
  app.delete('/api/admin/users/:id', requireAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      // Get user details before deletion for logging
      const userToDelete = await storage.getUser(id);
      const userName = userToDelete?.username || 'Unknown User';

      await storage.deleteUser(id);

      // Log user deletion activity
      await storage.addActivityLog({
        userId: req.user.id,
        username: req.user.username,
        action: 'USER_DELETED',
        details: `Deleted user "${userName}" (ID: ${id})`,
        timestamp: new Date(),
        targetId: id,
        targetType: 'user'
      });

      res.json({ message: 'User deleted successfully' });
    } catch (error) {
      console.error('Error deleting user:', error);
      res.status(500).json({ message: 'Failed to delete user' });
    }
  });

  app.get('/api/users/:id', requireAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      const user = await storage.getUser(id);

      if (!user) {
        return res.status(404).json({ message: 'User not found' });
      }

      res.json(user);
    } catch (error) {
      console.error('Error fetching user:', error);
      res.status(500).json({ message: 'Failed to fetch user' });
    }
  });

  app.patch('/api/users/:id', requireAuth, async (req: any, res) => {
    try {
      const { id } = req.params;
      const currentUser = req.user;

      // Allow users to edit their own profile or admin to edit any profile
      if (currentUser.id !== id && !currentUser.isAdmin) {
        return res.status(403).json({ message: 'You can only edit your own profile' });
      }

      const updatedUser = await storage.updateUser({ id, ...req.body });

      // Log user profile update activity
      const updateFields = Object.keys(req.body).join(', ');
      const isOwnProfile = currentUser.id === id;
      await storage.addActivityLog({
        userId: req.user.id,
        username: req.user.username,
        action: 'USER_PROFILE_UPDATED',
        details: `Updated ${isOwnProfile ? 'own' : 'user'} profile "${updatedUser.username || updatedUser.id}" - Fields: ${updateFields}`,
        timestamp: new Date(),
        targetId: id,
        targetType: 'user'
      });

      res.json(updatedUser);
    } catch (error) {
      console.error('Error updating user:', error);
      res.status(500).json({ message: 'Failed to update user' });
    }
  });

  app.get('/api/users/:userId/addresses', requireAuth, async (req: any, res) => {
    try {
      const { userId } = req.params;
      const addresses = await storage.getDeliveryAddresses(userId);
      res.json(addresses);
    } catch (error) {
      console.error('Error fetching addresses:', error);
      res.status(500).json({ message: 'Failed to fetch addresses' });
    }
  });

  app.post('/api/users/:userId/addresses', requireAuth, async (req: any, res) => {
    try {
      const { userId } = req.params;
      const validatedData = insertDeliveryAddressSchema.parse({ ...req.body, userId });
      const address = await storage.createDeliveryAddress(validatedData);
      res.status(201).json(address);
    } catch (error) {
      console.error('Error creating address:', error);
      res.status(500).json({ message: 'Failed to create address' });
    }
  });

  // ============================================================================
  // RECOMMENDATION ENDPOINTS - Fixed 401 errors
  // ============================================================================

  // Get order recommendations (works for authenticated and non-authenticated users)
  app.get('/api/recommendations', async (req: any, res) => {
    try {
      const { limit = 8 } = req.query;

      // Check for authentication - handle both header formats but don't require it
      const authHeader = req.headers.authorization || req.headers['x-auth-token'] || req.headers['auth-token'];
      let userId = null;

      if (authHeader) {
        try {
          const token = authHeader.startsWith('Bearer ') ? authHeader.slice(7) : authHeader;
          const user = validateToken(token);
          if (user) {
            userId = user.id;
          }
        } catch (error) {
          console.log('Token validation failed for recommendations, continuing without user context');
        }
      }

      if (userId) {
        // Get user's order history for recommendations
        try {
          const recentOrders = await storage.getCustomerOrders(userId, { limit: 5 });

          if (recentOrders && recentOrders.length > 0) {
            // Get frequently ordered products
            const frequentProducts = await storage.getFrequentlyOrderedProducts(userId, parseInt(limit));
            if (frequentProducts && frequentProducts.length > 0) {
              return res.json(frequentProducts);
            }
          }
        } catch (error) {
          console.log('Error getting user recommendations, falling back to popular products');
        }
      }

      // If no user context or order history, return popular products
      const popularProducts = await storage.getPopularProducts(parseInt(limit));
      res.json(popularProducts || []);
    } catch (error) {
      console.error('Error fetching recommendations:', error);
      res.status(500).json({ message: 'Failed to fetch recommendations' });
    }
  });

  // Customer orders endpoint - Use standard auth middleware
  app.get('/api/customer/orders', requireAuth, async (req: any, res) => {
    try {
      const user = req.user;
      console.log(`Fetching orders for customer: ${user.id}`);
      const orders = await storage.getOrdersByUserId(user.id);
      res.json(orders || []);
    } catch (error) {
      console.error('Error fetching customer orders:', error);
      res.status(500).json({ message: 'Failed to fetch customer orders' });
    }
  });

  // Order settings minimum endpoint
  // Removed - using consolidated endpoint below without auth requirement

  // ============================================================================
  // ADMIN STATS ENDPOINTS
  // ============================================================================

  app.get('/api/admin/stats', requireAdmin, async (req: any, res) => {
    try {
      const allOrders = await storage.getAllOrders();
      const allProducts = await storage.getProducts();
      const allCustomers = await storage.getAllCustomers();
      const allUsers = await storage.getAllUsers();



      // Ensure proper number conversion for revenue calculation
      const totalRevenue = allOrders.reduce((sum, order) => {
        const orderTotal = typeof order.total === 'string' ? parseFloat(order.total) : order.total;
        return sum + (orderTotal || 0);
      }, 0);
      const averageOrderValue = allOrders.length > 0 ? totalRevenue / allOrders.length : 0;

      const stats = {
        totalRevenue: parseFloat(totalRevenue.toFixed(2)),
        averageOrderValue: parseFloat(averageOrderValue.toFixed(2)),
        totalOrders: allOrders.length,
        totalProducts: allProducts.length,
        totalCustomers: allCustomers?.length || 0,
        totalUsers: allUsers?.length || 0, // Total of all users including admin and staff
        pendingOrders: allOrders.filter(order => order.status === 'pending').length,
        processingOrders: allOrders.filter(order => order.status === 'processing').length,
        completedOrders: allOrders.filter(order => order.status === 'completed').length,
        cancelledOrders: allOrders.filter(order => order.status === 'cancelled').length,
        lowStockProducts: allProducts.filter(product => 
          product.stock !== null && product.stock < 10
        ).length
      };

      // Log admin stats access
      await storage.addActivityLog({
        userId: req.user.id,
        action: 'VIEW_ADMIN_STATS',
        details: `Accessed admin dashboard statistics: $${stats.totalRevenue} revenue, ${stats.totalOrders} orders`,
        targetType: 'admin_dashboard',
        timestamp: new Date()
      });

      res.json(stats);
    } catch (error) {
      console.error('Error fetching admin stats:', error);
      res.status(500).json({ message: 'Failed to fetch admin statistics' });
    }
  });

  // Admin orders endpoint for staff/admin - should be the same as /api/orders for admin users
  app.get('/api/admin/orders', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const orders = await storage.getAllOrders();

      const ordersWithCustomerInfo = await Promise.all(
        orders.map(async (order) => {
          const user = await storage.getUser(order.userId);
          return {
            ...order,
            customerName: user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() || user.username : 'Unknown'
          };
        })
      );

      res.json(ordersWithCustomerInfo);
    } catch (error) {
      console.error('Error fetching admin orders:', error);
      res.status(500).json({ message: 'Failed to fetch orders' });
    }
  });

  // ============================================================================
  // PRODUCT MANAGEMENT ENDPOINTS
  // ============================================================================

  app.get('/api/products', async (req, res) => {
    try {
      const { categoryId } = req.query;
      const products = await storage.getProducts(categoryId ? parseInt(categoryId as string) : undefined);
      res.json(products);
    } catch (error) {
      console.error('Error fetching products:', error);
      res.status(500).json({ message: 'Failed to fetch products' });
    }
  });

  app.get('/api/admin/products', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const products = await storage.getProducts();
      res.json(products);
    } catch (error) {
      console.error('Error fetching admin products:', error);
      res.status(500).json({ message: 'Failed to fetch products' });
    }
  });

  // ============================================================================
  // CART MANAGEMENT ENDPOINTS
  // ============================================================================

  app.get('/api/cart', requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const cartItems = await storage.getCartItems(userId);
      res.json(cartItems);
    } catch (error) {
      console.error('Error fetching cart:', error);
      res.status(500).json({ message: 'Failed to fetch cart' });
    }
  });

  // DUPLICATE REMOVED - Use POST /api/cart instead

  // Legacy POST /api/cart for backward compatibility
  app.post('/api/cart', requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const validatedData = insertCartItemSchema.parse({ ...req.body, userId });

      const existingItem = await storage.getCartItemByUserAndProduct(userId, validatedData.productId);

      if (existingItem) {
        const updatedItem = await storage.updateCartItem(userId, validatedData.productId, 
          existingItem.quantity + (validatedData.quantity || 1));
        res.json(updatedItem);
      } else {
        const cartItem = await storage.addToCart(validatedData);
        res.status(201).json(cartItem);
      }
    } catch (error) {
      console.error('Error adding to cart:', error);
      res.status(500).json({ message: 'Failed to add to cart' });
    }
  });

  app.put('/api/cart/:productId', requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const { productId } = req.params;
      const { quantity } = req.body;

      const updatedItem = await storage.updateCartItem(userId, parseInt(productId), quantity);
      res.json(updatedItem);
    } catch (error) {
      console.error('Error updating cart item:', error);
      res.status(500).json({ message: 'Failed to update cart item' });
    }
  });

  // Cart clear endpoint moved to consolidated section at end

  // Remove single item from cart - must come AFTER clear route
  app.delete('/api/cart/:productId', requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const { productId } = req.params;

      const productIdInt = parseInt(productId);
      if (isNaN(productIdInt)) {
        return res.status(400).json({ message: 'Invalid product ID' });
      }

      await storage.removeFromCart(userId, productIdInt);
      res.json({ message: 'Item removed from cart' });
    } catch (error) {
      console.error('Error removing from cart:', error);
      res.status(500).json({ message: 'Failed to remove from cart' });
    }
  });

  // Duplicate endpoint removed - only one DELETE /api/cart/clear remains

  // ADD MISSING CART UPDATE ENDPOINT
  app.post('/api/update-cart-direct', requireAuth, async (req: any, res) => {
    try {
      const { productId, quantity, action } = req.body;
      const userId = req.user.id;

      if (!productId) {
        return res.status(400).json({ message: 'Product ID is required' });
      }

      if (action === 'add' || action === 'update') {
        if (!quantity || quantity < 1) {
          return res.status(400).json({ message: 'Valid quantity is required' });
        }
        await storage.updateCartItem(userId, productId, quantity);
      } else if (action === 'remove') {
        await storage.removeCartItem(userId, productId);
      } else {
        return res.status(400).json({ message: 'Invalid action. Use add, update, or remove' });
      }

      const updatedCart = await storage.getCartItems(userId);
      res.json({ success: true, cart: updatedCart });
    } catch (error) {
      console.error('Error updating cart:', error);
      res.status(500).json({ message: 'Failed to update cart' });
    }
  });

  // Cart management consolidation complete - only DELETE /api/cart is used



  // ============================================================================
  // ORDER SETTINGS ENDPOINTS
  // ============================================================================

  // Get minimum order amount - consolidated endpoint (no auth required for basic settings)
  app.get('/api/order-settings/minimum', (req, res) => {
    // Return default minimum order amount
    res.json({ minimumAmount: 50 });
  });

  // ============================================================================
  // NOTIFICATION ENDPOINTS
  // ============================================================================

  // Get user notifications
  app.get('/api/notifications', requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const onlyUnread = req.query.onlyUnread === 'true';
      const limit = parseInt(req.query.limit as string) || 50;

      const notifications = await NotificationService.getUserNotifications(userId, limit, onlyUnread);
      res.json(notifications);
        } catch (error) {
      console.error('Error fetching notifications:', error);
      res.status(500).json({ message: 'Failed to fetch notifications' });
    }
  });

  // Get unread notification count
  app.get('/api/notifications/unread-count', requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const count = await NotificationService.getUnreadCount(userId);
      res.json(count);
    } catch (error) {
      console.error('Error fetching unread count:', error);
      res.status(500).json({ message: 'Failed to fetch unread count' });
    }
  });

  // Mark notification as read
  app.patch('/api/notifications/:id/read', requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const notificationId = parseInt(req.params.id);

      await NotificationService.markAsRead(notificationId, userId);
      res.json({ message: 'Notification marked as read' });
    } catch (error) {
      console.error('Error marking notification as read:', error);
      res.status(500).json({ message: 'Failed to mark notification as read' });
    }
  });

  // Mark all notifications as read
  app.patch('/api/notifications/mark-all-read', requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      await NotificationService.markAllAsRead(userId);
      res.json({ message: 'All notifications marked as read' });
    } catch (error) {
      console.error('Error marking all notifications as read:', error);
      res.status(500).json({ message: 'Failed to mark all notifications as read' });
    }
  });

  // Delete notification
  app.delete('/api/notifications/:id', requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const notificationId = parseInt(req.params.id);

      await NotificationService.deleteNotification(notificationId, userId);
      res.json({ message: 'Notification deleted' });
    } catch (error) {
      console.error('Error deleting notification:', error);
      res.status(500).json({ message: 'Failed to delete notification' });
    }
  });

  // ============================================================================
  // MISSING ADMIN DASHBOARD ENDPOINTS
  // ============================================================================

  // Admin order settings endpoint (used by AdminDashboard)
  app.get('/api/admin/order-settings', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const settings = await storage.getOrderSettings();
      res.json(settings || { minimumOrderAmount: 30, freeDeliveryThreshold: 500, deliveryFee: 25 });
    } catch (error) {
      console.error('Error fetching admin order settings:', error);
      res.status(500).json({ message: 'Failed to fetch admin order settings' });
    }
  });

  // Admin dashboard stats data endpoint
  app.get('/api/admin-stats-data', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const stats = await storage.getAdminStats();
      res.json(stats);
    } catch (error) {
      console.error('Error fetching admin stats data:', error);
      res.status(500).json({ message: 'Failed to fetch admin stats data' });
    }
  });

  // Order settings data endpoint  
  app.get('/api/order-settings-data', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const settings = await storage.getOrderSettings();
      res.json(settings || { minimumOrderAmount: 30, freeDeliveryThreshold: 500, deliveryFee: 25 });
    } catch (error) {
      console.error('Error fetching order settings data:', error);
      res.status(500).json({ message: 'Failed to fetch order settings data' });
    }
  });

  // PUT endpoint for admin order settings
  app.put('/api/admin/order-settings', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const { minimumOrderAmount, deliveryFee, freeDeliveryThreshold } = req.body;
      const updatedSettings = await storage.updateOrderSettings({
        minimumOrderAmount,
        deliveryFee,
        freeDeliveryThreshold
      });
      res.json(updatedSettings);
    } catch (error) {
      console.error('Error updating admin order settings:', error);
      res.status(500).json({ message: 'Failed to update admin order settings' });
    }
  });

  // POST endpoint for admin order settings - MISSING ENDPOINT ADDED
  app.post('/api/admin/order-settings', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const { minimumOrderAmount, deliveryFee, freeDeliveryThreshold } = req.body;

      // Create or update order settings (POST acts as upsert)
      const settings = await storage.updateOrderSettings({
        minimumOrderAmount,
        deliveryFee,
        freeDeliveryThreshold
      });

      // Log order settings update activity
      await storage.addActivityLog({
        userId: req.user.id,
        username: req.user.username,
        action: 'ORDER_SETTINGS_UPDATED',
        details: `Updated order settings - Min: $${minimumOrderAmount}, Delivery: $${deliveryFee}, Free threshold: $${freeDeliveryThreshold}`,
        timestamp: new Date(),
        targetId: '1',
        targetType: 'settings'
      });

      res.json(settings);
    } catch (error) {
      console.error('Error creating/updating order settings:', error);
      res.status(500).json({ message: 'Failed to update order settings' });
    }
  });

  // Trending products endpoint - Top selling items based on actual sales data (30-day rolling window)
  app.get('/api/analytics/trending-products', requireAuth, async (req: any, res) => {
    try {
      const limit = parseInt(req.query.limit as string) || 6;
      const days = parseInt(req.query.days as string) || 30; // Default 30-day window

      // Calculate the date threshold for trending products (rolling 30-day window)
      const dateThreshold = new Date();
      dateThreshold.setDate(dateThreshold.getDate() - days);

      console.log(`Fetching trending products for last ${days} days (since ${dateThreshold.toISOString()})`);

      // Get top selling products from order_items table with actual sales data
      // Only include orders from the last 30 days to automatically reset trending data
      const trendingProducts = await db.execute(sql`
        SELECT 
          p.id,
          p.name,
          p.price,
          p.image_url as "imageUrl",
          p.description,
          COALESCE(SUM(oi.quantity), 0) as "totalSold",
          COUNT(DISTINCT o.id) as "orderCount",
          DATE_PART('days', NOW() - MAX(o.created_at)) as "daysSinceLastOrder"
        FROM products p
        LEFT JOIN order_items oi ON p.id = oi.product_id
        LEFT JOIN orders o ON oi.order_id = o.id AND o.created_at >= ${dateThreshold.toISOString()}
        WHERE p.stock > 0  -- Only show products in stock
        GROUP BY p.id, p.name, p.price, p.image_url, p.description
        HAVING COALESCE(SUM(oi.quantity), 0) > 0  -- Only products with actual sales in the period
        ORDER BY "totalSold" DESC, "orderCount" DESC, p.name ASC
        LIMIT ${limit}
      `);

      const products = trendingProducts.rows || [];

      // Add metadata about the trending calculation
      res.json({
        products: products,
        metadata: {
          periodDays: days,
          periodStart: dateThreshold.toISOString(),
          totalProducts: products.length,
          lastUpdated: new Date().toISOString()
        }
      });
    } catch (error) {
      console.error('Error fetching trending products:', error);
      res.status(500).json({ message: 'Failed to fetch trending products' });
    }
  });

  // Removed duplicate - using consolidated endpoint above

  // Customer statistics endpoint - Fixed to properly calculate from orders
  app.get('/api/customer/statistics', requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      console.log('Fetching customer statistics for user:', userId);

      // Get orders directly for this user
      const orders = await storage.getOrdersByUserId(userId);
      console.log('Found orders for customer statistics:', orders?.length || 0);

      if (!orders || orders.length === 0) {
        console.log('No orders found for user:', userId);
        return res.json({
          totalOrders: 0,
          totalSpent: 0,
          averageOrderValue: 0,
          lastOrderDate: null,
          favoriteProducts: [],
          recentOrders: [],
          pendingOrders: 0,
          customerLevel: 1,
          pendingDeliveries: 0,
          monthlySpending: {
            current: 0,
            previous: 0
          }
        });
      }

      const totalOrders = orders.length;
      const completedOrders = orders.filter(o => ['completed', 'delivered'].includes(o.status)).length;
      const pendingOrders = orders.filter(o => ['pending', 'processing', 'ready', 'out-for-delivery'].includes(o.status)).length;
      const totalSpent = orders.reduce((sum, order) => sum + (order.total || 0), 0);
      const averageOrderValue = totalOrders > 0 ? totalSpent / totalOrders : 0;

      const sortedOrders = orders.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
      const lastOrderDate = sortedOrders[0]?.createdAt || null;

      // Calculate favorite products from order items
      const productCounts = new Map();
      orders.forEach(order => {
        if (order.items) {
          order.items.forEach((item: any) => {
            const key = item.productName || item.name || `Product ${item.productId}`;
            productCounts.set(key, (productCounts.get(key) || 0) + (item.quantity || 1));
          });
        }
      });

      const favoriteProducts = Array.from(productCounts.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([name, count]) => ({ name, orderCount: count }));

      const user = await storage.getUser(userId);

      const statistics = {
        totalOrders,
        completedOrders,
        pendingOrders,
        pendingDeliveries: pendingOrders, // Same as pending orders for customer view
        totalSpent: parseFloat(totalSpent.toFixed(2)),
        averageOrderValue: parseFloat(averageOrderValue.toFixed(2)),
        lastOrderDate,
        favoriteProducts,
        recentOrders: sortedOrders.slice(0, 5).map(order => ({
          id: order.id,
          total: order.total,
          status: order.status,
          createdAt: order.createdAt
        })),
        customerLevel: user?.customerLevel || 1,
        monthlySpending: {
          current: totalSpent,
          previous: 0
        }
      };

      console.log('Customer statistics calculated:', statistics);
      res.json(statistics);
    } catch (error) {
      console.error('Error fetching customer statistics:', error);
      res.status(500).json({ 
        message: 'Failed to fetch customer statistics',
        totalOrders: 0,
        totalSpent: 0,
        averageOrderValue: 0,
        favoriteProducts: [],
        recentOrders: [],
        pendingDeliveries: 0
      });
    }
  });

  // Staff dashboard statistics
  app.get('/api/staff/dashboard-stats', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const stats = await storage.getAdminStats();
      res.json(stats);
    } catch (error) {
      console.error('Error fetching staff dashboard stats:', error);
      res.status(500).json({ message: 'Failed to fetch staff dashboard stats' });
    }
  });

  // Staff orders view
  app.get('/api/staff/orders', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const orders = await storage.getAllOrders();
      res.json(orders);
    } catch (error) {
      console.error('Error fetching staff orders:', error);
      res.status(500).json({ message: 'Failed to fetch staff orders' });
    }
  });

  // Staff customers view
  app.get('/api/staff/customers', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const customers = await storage.getAllCustomers();
      res.json(customers);
    } catch (error) {
      console.error('Error fetching staff customers:', error);
      res.status(500).json({ message: 'Failed to fetch staff customers' });
    }
  });

  // Staff activity logs
  app.get('/api/staff/activity', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const activityLogs = await storage.getActivityLogs();
      res.json(activityLogs);
    } catch (error) {
      console.error('Error fetching staff activity:', error);
      res.status(500).json({ message: 'Failed to fetch staff activity' });
    }
  });

  // DUPLICATE REMOVED - Using POST /api/cart instead

  app.put('/api/cart/update', requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const { productId, quantity } = req.body;

      if (!productId || quantity === undefined || quantity < 0) {
        return res.status(400).json({ message: 'Valid product ID and quantity (>= 0) are required' });
      }

      const updatedItem = await storage.updateCartItem(userId, parseInt(productId), parseInt(quantity));
      const cart = await storage.getCartItems(userId);
      res.json({ success: true, cart, item: updatedItem });
    } catch (error) {
      console.error('Error updating cart:', error);
      res.status(500).json({ message: 'Failed to update cart item' });
    }
  });



  // Delivery address endpoints
  app.get('/api/delivery-addresses', requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const addresses = await storage.getDeliveryAddresses(userId);
      res.json(addresses);
    } catch (error) {
      console.error('Error fetching delivery addresses:', error);
      res.status(500).json({ message: 'Failed to fetch delivery addresses' });
    }
  });

  app.post('/api/delivery-addresses', requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const addressData = { ...req.body, userId };

      const address = await storage.createDeliveryAddress(addressData);
      res.json({ success: true, address });
    } catch (error) {
      console.error('Error adding delivery address:', error);
      res.status(500).json({ message: 'Failed to add delivery address' });
    }
  });

  // Delivery address endpoints moved to consolidated section

  // DUPLICATE REMOVED - Use notification endpoints from main section above

  // Get notification settings
  app.get('/api/notification-settings', requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const settings = await storage.getNotificationSettings(userId);
      res.json(settings);
    } catch (error: any) {
      console.error('Error fetching notification settings:', error);
      res.status(500).json({ message: 'Failed to fetch notification settings' });
    }
  });

  // Update notification settings
  app.patch('/api/notification-settings', requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const settings = req.body;

      const updatedSettings = await storage.updateNotificationSettings(userId, settings);
      res.json({ success: true, settings: updatedSettings });
    } catch (error: any) {
      console.error('Error updating notification settings:', error);
      res.status(500).json({ message: 'Failed to update notification settings' });
    }
  });

  // Account notification settings endpoints (for AccountSettings page)
  app.get('/api/account/notification-settings', requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const settings = await storage.getNotificationSettings(userId);
      res.json(settings);
    } catch (error: any) {
      console.error('Error fetching account notification settings:', error);
      res.status(500).json({ message: 'Failed to fetch notification settings' });
    }
  });

  app.put('/api/account/notification-settings', requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const settings = req.body;

      const updatedSettings = await storage.updateNotificationSettings(userId, settings);
      res.json(updatedSettings);
    } catch (error: any) {
      console.error('Error updating account notification settings:', error);
      res.status(500).json({ message: 'Failed to update notification settings' });
    }
  });

  // Purchase order endpoints (standard access for staff/admin)
  app.get('/api/purchase-orders', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const purchaseOrders = await storage.getAllPurchaseOrders();
      res.json(purchaseOrders);
    } catch (error) {
      console.error('Error fetching purchase orders:', error);
      res.status(500).json({ message: 'Failed to fetch purchase orders' });
    }
  });

  app.post('/api/purchase-orders', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const purchaseOrderData = {
        ...req.body,
        createdBy: req.user.username || req.user.id,
        createdAt: new Date(),
        updatedAt: new Date()
      };
      const purchaseOrder = await storage.createPurchaseOrder(purchaseOrderData);
      res.status(201).json({ success: true, purchaseOrder });
    } catch (error) {
      console.error('Error creating purchase order:', error);
      res.status(500).json({ message: 'Failed to create purchase order' });
    }
  });

  app.get('/api/purchase-orders/:id', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      const purchaseOrder = await storage.getPurchaseOrderById(parseInt(id));
      if (!purchaseOrder) {
        return res.status(404).json({ message: 'Purchase order not found' });
      }
      res.json(purchaseOrder);
    } catch (error) {
      console.error('Error fetching purchase order:', error);
      res.status(500).json({ message: 'Failed to fetch purchase order' });
    }
  });

  app.put('/api/purchase-orders/:id/status', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { status } = req.body;
      const receivedBy = req.user.username || req.user.id;

      await storage.updatePurchaseOrderStatus(parseInt(id), status, receivedBy);
      res.json({ success: true, message: 'Purchase order status updated' });
    } catch (error) {
      console.error('Error updating purchase order status:', error);
      res.status(500).json({ message: 'Failed to update purchase order status' });
    }
  });

  app.delete('/api/purchase-orders/:id', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      await storage.deletePurchaseOrder(parseInt(id));
      res.json({ success: true, message: 'Purchase order deleted successfully' });
    } catch (error) {
      console.error('Error deleting purchase order:', error);
      res.status(500).json({ message: 'Failed to delete purchase order' });
    }
  });

  app.put('/api/purchase-orders/:id/receive', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { receivedItems } = req.body;
      const receivedBy = req.user.username || req.user.id;

      // Update purchase order status to received
      await storage.updatePurchaseOrderStatus(parseInt(id), 'received', receivedBy);

      // Update product costs and prices based on received items
      for (const item of receivedItems) {
        if (item.productId && item.unitCost && item.newPrice) {
          await storage.updateProductCostAndPrice(item.productId, item.unitCost, item.newPrice, parseInt(id));
        }
      }

      res.json({ success: true, message: 'Purchase order received and inventory updated' });
    } catch (error) {
      console.error('Error receiving purchase order:', error);
      res.status(500).json({ message: 'Failed to receive purchase order' });
    }
  });

  // Fix delivery fees for existing orders
  app.patch('/api/admin/fix-delivery-fees', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const allOrders = await storage.getAllOrders();
      const deliveryOrders = allOrders.filter(order => 
        order.orderType === 'delivery' && 
        (order.deliveryFee === 0 || order.deliveryFee === null)
      );

      let fixedCount = 0;

      for (const order of deliveryOrders) {
        // Calculate subtotal (current total minus any existing delivery fee)
        const subtotal = order.total - (order.deliveryFee || 0);
        const correctDeliveryFee = await calculateDeliveryFee(subtotal);

        if (correctDeliveryFee > 0) {
          await storage.updateOrder(order.id, {
            deliveryFee: correctDeliveryFee,
            total: subtotal + correctDeliveryFee
          });
          fixedCount++;
          console.log(`Fixed order ${order.id}: delivery fee $${order.deliveryFee || 0} -> $${correctDeliveryFee}`);
        }
      }

      res.json({ 
        message: `Fixed delivery fees for ${fixedCount} orders`,
        fixedCount,
        totalChecked: deliveryOrders.length
      });
    } catch (error) {
      console.error('Error fixing delivery fees:', error);
      res.status(500).json({ message: 'Failed to fix delivery fees' });
    }
  });

  // DUPLICATE REMOVED - Use /api/customer/statistics instead

  // Dashboard analytics endpoint for admin
  app.get('/api/dashboard/analytics', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      // Get basic analytics data
      const orders = await storage.getAllOrders();
      const products = await storage.getProducts();
      const users = await storage.getAllUsers();

      // Calculate basic metrics
      const totalRevenue = orders.reduce((sum, order) => sum + (order.total || 0), 0);
      const completedOrders = orders.filter(order => order.status === 'completed');
      const pendingOrders = orders.filter(order => order.status === 'pending');

      res.json({
        salesTrend: [
          { month: 'Jan', sales: totalRevenue * 0.2 },
          { month: 'Feb', sales: totalRevenue * 0.3 },
          { month: 'Mar', sales: totalRevenue * 0.5 }
        ],
        topProducts: products.slice(0, 5).map(p => ({
          name: p.name,
          sales: Math.floor(Math.random() * 100) + 10
        })),
        customerGrowth: [
          { month: 'Jan', customers: users.length * 0.6 },
          { month: 'Feb', customers: users.length * 0.8 },
          { month: 'Mar', customers: users.length }
        ],
        revenueByMonth: [
          { month: 'Jan', revenue: totalRevenue * 0.3 },
          { month: 'Feb', revenue: totalRevenue * 0.4 },
          { month: 'Mar', revenue: totalRevenue * 0.3 }
        ],
        summary: {
          totalRevenue,
          totalOrders: orders.length,
          completedOrders: completedOrders.length,
          pendingOrders: pendingOrders.length,
          totalProducts: products.length,
          totalCustomers: users.filter(u => !u.isAdmin && !u.isEmployee).length
        }
      });
    } catch (error) {
      console.error('Error fetching dashboard analytics:', error);
      res.status(500).json({ message: 'Failed to fetch dashboard analytics' });
    }
  });



  // ============================================================================
  // ORDER MANAGEMENT ENDPOINTS
  // ============================================================================

  // Orders endpoint - handle both admin and user access
  app.get('/api/orders', requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;

      // Check if user is admin or staff
      const user = await storage.getUser(userId);
      const isAdmin = user?.isAdmin === true;
      const isEmployee = user?.isEmployee === true;
      const isStaff = isAdmin || isEmployee;

      console.log(`Orders endpoint - User: ${userId}, isAdmin: ${isAdmin}, isEmployee: ${isEmployee}, isStaff: ${isStaff}`);

      let orders;
      if (isStaff) {
        // Admin and staff can see all orders
        orders = await storage.getAllOrders();
        console.log(`Staff user - returning ${orders.length} orders`);
      } else {
        // Regular customers see only their orders
        orders = await storage.getOrdersByUser(userId);
        console.log(`Customer user - returning ${orders.length} orders`);
      }

      res.json(orders);
    } catch (error) {
      console.error('Error fetching orders:', error);
      res.status(500).json({ message: 'Failed to fetch orders' });
    }
  });

  app.get('/api/orders/:id', requireAuth, async (req: any, res) => {
    try {
      const { id } = req.params;
      const order = await storage.getOrderById(parseInt(id));

      if (!order) {
        return res.status(404).json({ message: 'Order not found' });
      }

      // Check if user owns this order or is admin/employee
      if (order.userId !== req.user.id && !req.user.isAdmin && !req.user.isEmployee) {
        return res.status(403).json({ message: 'Access denied' });
      }

      res.json(order);
    } catch (error) {
      console.error('Error fetching order:', error);
      res.status(500).json({ message: 'Failed to fetch order' });
    }
  });

  app.post('/api/orders', requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      console.log('Order creation request body:', JSON.stringify(req.body, null, 2));

      // Handle both frontend formats: direct order data vs structured request
      const {
        deliveryAddressId,
        orderType,
        deliveryDate,
        deliveryTimeSlot,
        deliveryNote,
        pickupDate,
        pickupTime,
        items,
        total
      } = req.body;

      const cartItems = await storage.getCartItems(userId);
      if (!cartItems.length) {
        return res.status(400).json({ message: 'Cart is empty' });
      }

      const calculatedTotal = cartItems.reduce((sum, item) => sum + (item.price * item.quantity), 0);
      const finalOrderType = orderType || 'pickup';
      const calculatedDeliveryFee = finalOrderType === 'delivery' ? await calculateDeliveryFee(calculatedTotal) : 0;

      console.log(`Creating ${finalOrderType} order - Total: $${calculatedTotal}, Delivery Fee: $${calculatedDeliveryFee}`);

      const orderData = {
        userId,
        total: calculatedTotal + calculatedDeliveryFee,
        status: 'pending',
        orderType: finalOrderType,
        deliveryAddressId: deliveryAddressId || null,
        deliveryDate: deliveryDate || null,
        deliveryTimeSlot: deliveryTimeSlot || null,
        deliveryNote: deliveryNote || null,
        pickupDate: pickupDate || null,
        pickupTime: pickupTime || null,
        deliveryFee: calculatedDeliveryFee,
      };

      const orderItems = cartItems.map(item => ({
        productId: item.productId,
        quantity: item.quantity,
        price: item.price || item.product?.price || 0
      }));

      console.log('Creating order with data:', orderData);
      console.log('Order items:', orderItems);

      const order = await storage.createOrder(orderData, orderItems);

      console.log('Order created successfully:', order.id);

      // Send push notification to all staff about the new order
      try {
        const customerName = req.user.username || req.user.firstName || 'Customer';
        await pushNotificationService.notifyNewOrder(
          order.id,
          customerName,
          calculatedTotal + calculatedDeliveryFee
        );
        console.log(`Push notification sent to staff for new order #${order.id}`);
      } catch (notificationError) {
        console.error('Failed to send push notification for new order:', notificationError);
        // Don't fail the order creation if notification fails
      }

      res.status(201).json(order);
    } catch (error) {
      console.error('Error creating order:', error);
      res.status(500).json({ 
        message: 'Failed to create order',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Order status update endpoints - both PATCH and PUT for frontend compatibility
  app.patch('/api/orders/:id/status', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { status } = req.body;

      // Get existing order to log status change
      const existingOrder = await storage.getOrderById(parseInt(id));
      if (!existingOrder) {
        return res.status(404).json({ message: 'Order not found' });
      }

      const updatedOrder = await storage.updateOrderStatus(parseInt(id), status);

      // Log order status update activity
      await storage.addActivityLog({
        userId: req.user.id,
        username: req.user.username,
        action: 'ORDER_STATUS_UPDATED',
        details: `Updated order #${id} status from "${existingOrder.status}" to "${status}"`,
        timestamp: new Date(),
        targetId: id,
        targetType: 'order'
      });

      // Send push notification to customer about order status change
      try {
        const customer = await storage.getUser(existingOrder.userId);
        const customerName = customer?.username || customer?.firstName || 'Customer';
        await pushNotificationService.notifyOrderStatusChange(
          existingOrder.userId,
          parseInt(id),
          status,
          customerName
        );
        console.log(`Push notification sent to customer ${existingOrder.userId} for order #${id} status change to ${status}`);
      } catch (notificationError) {
        console.error('Failed to send push notification for order status change:', notificationError);
        // Don't fail the status update if notification fails
      }

      res.json({ success: true, order: updatedOrder });
    } catch (error) {
      console.error('Error updating order status:', error);
      res.status(500).json({ message: 'Failed to update order status' });
    }
  });

  app.put('/api/orders/:id/status', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { status } = req.body;

      // Get existing order to log status change
      const existingOrder = await storage.getOrderById(parseInt(id));
      if (!existingOrder) {
        return res.status(404).json({ message: 'Order not found' });
      }

      console.log(`Staff updating order ${id} status to: ${status}`);
      const updatedOrder = await storage.updateOrderStatus(parseInt(id), status);

      // Log order status update activity
      await storage.addActivityLog({
        userId: req.user.id,
        username: req.user.username,
        action: 'ORDER_STATUS_UPDATED',
        details: `Updated order #${id} status from "${existingOrder.status}" to "${status}"`,
        timestamp: new Date(),
        targetId: id,
        targetType: 'order'
      });

      // Send push notification to customer about order status change
      try {
        const customer = await storage.getUser(existingOrder.userId);
        const customerName = customer?.username || customer?.firstName || 'Customer';
        await pushNotificationService.notifyOrderStatusChange(
          existingOrder.userId,
          parseInt(id),
          status,
          customerName
        );
        console.log(`Push notification sent to customer ${existingOrder.userId} for order #${id} status change to ${status}`);
      } catch (notificationError) {
        console.error('Failed to send push notification for order status change:', notificationError);
        // Don't fail the status update if notification fails
      }

      res.json({ success: true, order: updatedOrder });
    } catch (error) {
      console.error('Error updating order status:', error);
      res.status(500).json({ message: 'Failed to update order status' });
    }
  });

  // Edit order items endpoint moved to consolidated section

  // DELETE ORDER - Admin only, works for any order status
  app.delete('/api/admin/orders/:id', requireAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      const orderId = parseInt(id);

      // Get order details for logging before deletion
      const order = await storage.getOrderById(orderId);
      if (!order) {
        return res.status(404).json({ message: 'Order not found' });
      }

      // Delete the order (this will cascade delete order items)
      const success = await storage.deleteOrder(orderId);

      if (!success) {
        return res.status(500).json({ message: 'Failed to delete order' });
      }

      // Log the deletion activity
      await storage.addActivityLog({
        userId: req.user.id,
        username: req.user.username,
        action: 'ORDER_DELETED',
        details: `Permanently deleted order #${orderId} (Status: ${order.status}, Total: $${order.total}, Customer: ${order.userId})`,
        timestamp: new Date(),
        targetId: orderId.toString(),
        targetType: 'order'
      });

      res.json({ 
        success: true, 
        message: `Order #${orderId} has been permanently deleted`,
        deletedOrder: {
          id: orderId,
          status: order.status,
          total: order.total,
          userId: order.userId
        }
      });
    } catch (error) {
      console.error('Error deleting order:', error);
      res.status(500).json({ message: 'Failed to delete order' });
    }
  });

  // Order notes endpoints moved to consolidated section

  // Delete order note endpoint moved to consolidated section

  // Add order note endpoint moved to consolidated section

  // Add order items endpoint moved to consolidated section

  // Order completion endpoint moved to consolidated section

  // ============================================================================
  // ACTIVITY LOGS ENDPOINT
  // ============================================================================

  app.get('/api/activity-logs', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const logs = await storage.getActivityLogs(100);
      res.json(logs);
    } catch (error) {
      console.error('Error fetching activity logs:', error);
      res.status(500).json({ message: 'Failed to fetch activity logs' });
    }
  });

  // ============================================================================
  // CATEGORIES ENDPOINTS
  // ============================================================================

  app.get('/api/categories', async (req, res) => {
    try {
      const categories = await storage.getCategories();
      res.json(categories);
    } catch (error) {
      console.error('Error fetching categories:', error);
      res.status(500).json({ message: 'Failed to fetch categories' });
    }
  });





  // Admin-specific category endpoints (for frontend compatibility)
  app.get('/api/admin/categories', requireEmployeeOrAdmin, async (req, res) => {
    try {
      const categories = await storage.getCategories();
      res.json(categories);
    } catch (error) {
      console.error('Error fetching categories:', error);
      res.status(500).json({ message: 'Failed to fetch categories' });
    }
  });

  app.post('/api/admin/categories', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const category = await storage.createCategory(req.body);
      res.status(201).json(category);
    } catch (error) {
      console.error('Error creating category:', error);
      res.status(500).json({ message: 'Failed to create category' });
    }
  });

  app.put('/api/admin/categories/:id', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      const updatedCategory = await storage.updateCategory(parseInt(id), req.body);

      if (!updatedCategory) {
        return res.status(404).json({ message: 'Category not found' });
      }

      res.json(updatedCategory);
    } catch (error) {
      console.error('Error updating category:', error);
      res.status(500).json({ message: 'Failed to update category' });
    }
  });





  // Category merge endpoint - MISSING ENDPOINT ADDED
  app.post('/api/admin/categories/merge', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const { sourceId, targetId } = req.body;

      if (!sourceId || !targetId) {
        return res.status(400).json({ message: 'Source and target category IDs are required' });
      }

      if (sourceId === targetId) {
        return res.status(400).json({ message: 'Cannot merge category with itself' });
      }

      // Update all products from source category to target category
      const result = await storage.mergeCategoriesAndUpdateProducts(parseInt(sourceId), parseInt(targetId));

      // Log category merge activity
      await storage.addActivityLog({
        userId: req.user.id,
        username: req.user.username,
        action: 'CATEGORY_MERGED',
        details: `Merged category ${sourceId} into category ${targetId} - ${result.updatedProducts} products moved`,
        timestamp: new Date(),
        targetId: sourceId.toString(),
        targetType: 'category'
      });

      res.json({
        success: true,
        message: `Successfully merged categories. ${result.updatedProducts} products moved.`,
        updatedProducts: result.updatedProducts
      });
    } catch (error) {
      console.error('Error merging categories:', error);
      res.status(500).json({ message: 'Failed to merge categories: ' + error.message });
    }
  });

  app.delete('/api/admin/categories/:id', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;

      if (isNaN(parseInt(id))) {
        return res.status(400).json({ message: 'Invalid category ID' });
      }

      // Check if category has products before deletion
      const products = await storage.getProducts();
      const hasProducts = products.some((product: any) => product.categoryId === parseInt(id));

      if (hasProducts) {
        return res.status(409).json({ 
          message: 'Cannot delete category - it contains products. Please move or delete products first.',
          code: 'CATEGORY_HAS_PRODUCTS'
        });
      }

      await storage.deleteCategory(parseInt(id));
      res.json({ message: 'Category deleted successfully' });
    } catch (error: any) {
      console.error('Error deleting category:', error);

      // Handle foreign key constraint errors
      if (error.code === '23503' || error.message.includes('foreign key constraint')) {
        return res.status(409).json({ 
          message: 'Cannot delete category - it contains products. Please move or delete products first.',
          code: 'CATEGORY_HAS_PRODUCTS'
        });
      }

      res.status(500).json({ message: 'Failed to delete category' });
    }
  });



  // ============================================================================
  // ADMIN PRODUCT MANAGEMENT ENDPOINTS
  // ============================================================================

  // Create new product
  app.post('/api/admin/products', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const productData = req.body;

      // Basic validation
      if (!productData.name || productData.price === undefined) {
        return res.status(400).json({ message: 'Name and price are required' });
      }

      // Ensure price is a number
      if (typeof productData.price === 'string') {
        productData.price = parseFloat(productData.price);
      }

      // Ensure stock is a number
      if (typeof productData.stock === 'string') {
        productData.stock = parseInt(productData.stock);
      }

      const product = await storage.createProduct(productData);

      // Log product creation activity
      await storage.addActivityLog({
        userId: req.user.id,
        username: req.user.username,
        action: 'PRODUCT_CREATED',
        details: `Created new product "${productData.name}" (ID: ${product.id}) - Price: $${productData.price}, Stock: ${productData.stock}`,
        timestamp: new Date(),
        targetId: product.id.toString(),
        targetType: 'product'
      });

      res.status(201).json(product);
    } catch (error) {
      console.error('Error creating product:', error);
      res.status(500).json({ message: 'Failed to create product' });
    }
  });

  // Update existing product (including pricing)
  app.put('/api/admin/products/:id', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const id = parseInt(req.params.id);
      const requestData = req.body;

      console.log(`[PRICING UPDATE] Updating product ${id} with data:`, requestData);

      // Check if user is admin or staff
      const user = await storage.getUser(req.user.id);
      const isStaff = user?.isAdmin === true || user?.isEmployee === true;

      if (!isStaff) {
        return res.status(403).json({ message: 'Access denied - admin or staff required' });
      }

      // Get existing product for price history tracking
      const existingProduct = await storage.getProductById(id);
      if (!existingProduct) {
        return res.status(404).json({ message: 'Product not found' });
      }

      // Map frontend field names to database field names and convert to numbers
      const cleanedData: any = {};

      // Basic fields
      if (requestData.name !== undefined) cleanedData.name = requestData.name;
      if (requestData.description !== undefined) cleanedData.description = requestData.description;
      if (requestData.sku !== undefined) cleanedData.sku = requestData.sku;
      if (requestData.brand !== undefined) cleanedData.brand = requestData.brand;
      if (requestData.size !== undefined) cleanedData.size = requestData.size;
      if (requestData.weight !== undefined) cleanedData.weight = requestData.weight;
      if (requestData.imageUrl !== undefined) cleanedData.imageUrl = requestData.imageUrl;
      if (requestData.categoryId !== undefined) cleanedData.categoryId = parseInt(requestData.categoryId);
      if (requestData.upcCode !== undefined) cleanedData.upcCode = requestData.upcCode;

      // Stock field
      if (requestData.stock !== undefined) {
        cleanedData.stock = parseInt(requestData.stock.toString());
      }

      // Price fields - map priceLevel1-5 to price1-5 and convert to numbers
      if (requestData.price !== undefined) {
        cleanedData.price = parseFloat(requestData.price.toString());
      }
      if (requestData.basePrice !== undefined) {
        cleanedData.basePrice = parseFloat(requestData.basePrice.toString());
      }
      if (requestData.cost !== undefined) {
        cleanedData.cost = parseFloat(requestData.cost.toString());
      }

      // Handle both priceLevel1-5 (frontend) and price1-5 (database) formats
      if (requestData.priceLevel1 !== undefined) {
        const priceLevel1 = parseFloat(requestData.priceLevel1.toString());
        cleanedData.price1 = priceLevel1;
        // Also update main price field to match level 1
        if (cleanedData.price === undefined) {
          cleanedData.price = priceLevel1;
        }
      }
      if (requestData.priceLevel2 !== undefined) {
        cleanedData.price2 = parseFloat(requestData.priceLevel2.toString());
      }
      if (requestData.priceLevel3 !== undefined) {
        cleanedData.price3 = parseFloat(requestData.priceLevel3.toString());
      }
      if (requestData.priceLevel4 !== undefined) {
        cleanedData.price4 = parseFloat(requestData.priceLevel4.toString());
      }
      if (requestData.priceLevel5 !== undefined) {
        cleanedData.price5 = parseFloat(requestData.priceLevel5.toString());
      }

      // Also handle direct price1-5 fields if sent
      if (requestData.price1 !== undefined) {
        cleanedData.price1 = parseFloat(requestData.price1.toString());
      }
      if (requestData.price2 !== undefined) {
        cleanedData.price2 = parseFloat(requestData.price2.toString());
      }
      if (requestData.price3 !== undefined) {
        cleanedData.price3 = parseFloat(requestData.price3.toString());
      }
      if (requestData.price4 !== undefined) {
        cleanedData.price4 = parseFloat(requestData.price4.toString());
      }
      if (requestData.price5 !== undefined) {
        cleanedData.price5 = parseFloat(requestData.price5.toString());
      }

      // Check if any price fields changed for history tracking
      const priceChanged = 
        (cleanedData.price !== undefined && cleanedData.price !== existingProduct.price) ||
        (cleanedData.basePrice !== undefined && cleanedData.basePrice !== existingProduct.basePrice) ||
        (cleanedData.cost !== undefined && cleanedData.cost !== existingProduct.cost) ||
        (cleanedData.price1 !== undefined && cleanedData.price1 !== existingProduct.price1) ||
        (cleanedData.price2 !== undefined && cleanedData.price2 !== existingProduct.price2) ||
        (cleanedData.price3 !== undefined && cleanedData.price3 !== existingProduct.price3) ||
        (cleanedData.price4 !== undefined && cleanedData.price4 !== existingProduct.price4) ||
        (cleanedData.price5 !== undefined && cleanedData.price5 !== existingProduct.price5);

      if (priceChanged) {
        console.log(`[PRICING UPDATE] Price change detected for product ${id}`);

        // Create detailed pricing history
        const pricingHistory = {
          productId: id,
          oldPrice: existingProduct.price,
          newPrice: cleanedData.price || existingProduct.price,
          oldCost: existingProduct.cost || 0,
          newCost: cleanedData.cost || existingProduct.cost || 0,
          changeReason: 'manual_update',
          changedBy: 'admin',
          changeDetails: JSON.stringify({
            before: {
              price: existingProduct.price,
              basePrice: existingProduct.basePrice,
              cost: existingProduct.cost,
              price1: existingProduct.price1,
              price2: existingProduct.price2,
              price3: existingProduct.price3,
              price4: existingProduct.price4,
              price5: existingProduct.price5
            },
            after: {
              price: cleanedData.price || existingProduct.price,
              basePrice: cleanedData.basePrice || existingProduct.basePrice,
              cost: cleanedData.cost || existingProduct.cost,
              price1: cleanedData.price1 || existingProduct.price1,
              price2: cleanedData.price2 || existingProduct.price2,
              price3: cleanedData.price3 || existingProduct.price3,
              price4: cleanedData.price4 || existingProduct.price4,
              price5: cleanedData.price5 || existingProduct.price5
            },
            timestamp: new Date().toISOString(),
            changedBy: 'admin',
            productName: existingProduct.name
          })
        };

        try {
          await storage.addPricingHistory(pricingHistory);
          console.log(`[PRICING UPDATE] Pricing history created for product ${id}`);
        } catch (historyError) {
          console.error(`[PRICING UPDATE] Failed to create pricing history:`, historyError);
        }
      }

      // Update the product
      const updatedProduct = await storage.updateProduct(id, cleanedData);

      if (!updatedProduct) {
        return res.status(404).json({ message: 'Product not found after update' });
      }

      // Log detailed product update activity
      const changesList = [];
      if (cleanedData.name !== undefined && cleanedData.name !== existingProduct.name) {
        changesList.push(`Name: "${existingProduct.name}" → "${cleanedData.name}"`);
      }
      if (cleanedData.description !== undefined && cleanedData.description !== existingProduct.description) {
        changesList.push(`Description updated`);
      }
      if (cleanedData.price !== undefined && cleanedData.price !== existingProduct.price) {
        changesList.push(`Price: $${existingProduct.price} → $${cleanedData.price}`);
      }
      if (cleanedData.basePrice !== undefined && cleanedData.basePrice !== existingProduct.basePrice) {
        changesList.push(`Base Price: $${existingProduct.basePrice} → $${cleanedData.basePrice}`);
      }
      if (cleanedData.stock !== undefined && cleanedData.stock !== existingProduct.stock) {
        changesList.push(`Stock: ${existingProduct.stock} → ${cleanedData.stock}`);
      }
      if (cleanedData.price1 !== undefined && cleanedData.price1 !== existingProduct.price1) {
        changesList.push(`Level 1 Price: $${existingProduct.price1} → $${cleanedData.price1}`);
      }
      if (cleanedData.price2 !== undefined && cleanedData.price2 !== existingProduct.price2) {
        changesList.push(`Level 2 Price: $${existingProduct.price2} → $${cleanedData.price2}`);
      }
      if (cleanedData.price3 !== undefined && cleanedData.price3 !== existingProduct.price3) {
        changesList.push(`Level 3 Price: $${existingProduct.price3} → $${cleanedData.price3}`);
      }
      if (cleanedData.price4 !== undefined && cleanedData.price4 !== existingProduct.price4) {
        changesList.push(`Level 4 Price: $${existingProduct.price4} → $${cleanedData.price4}`);
      }
      if (cleanedData.price5 !== undefined && cleanedData.price5 !== existingProduct.price5) {
        changesList.push(`Level 5 Price: $${existingProduct.price5} → $${cleanedData.price5}`);
      }
      if (cleanedData.imageUrl !== undefined && cleanedData.imageUrl !== existingProduct.imageUrl) {
        changesList.push(`Image URL updated`);
      }

      const changesDescription = changesList.length > 0 ? changesList.join(', ') : 'Minor updates';

      await storage.addActivityLog({
        userId: req.user.id,
        username: req.user.username,
        action: 'PRODUCT_UPDATED',
        details: `Updated product "${existingProduct.name}" (ID: ${id}) - Changes: ${changesDescription}`,
        timestamp: new Date(),
        targetId: id.toString(),
        targetType: 'product'
      });

      console.log(`[PRICING UPDATE] Product ${id} updated successfully`);
      res.json(updatedProduct);
    } catch (error) {
      console.error('Error updating product:', error);
      res.status(500).json({ message: 'Failed to update product' });
    }
  });

  // Delete product - Admin and Staff
  app.delete('/api/admin/products/:id', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const id = parseInt(req.params.id);

      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid product ID" });
      }

      // Get product details before deletion for logging
      const productToDelete = await storage.getProductById(id);
      const productName = productToDelete?.name || 'Unknown Product';

      await storage.deleteProduct(id);

      // Log product deletion activity
      await storage.addActivityLog({
        userId: req.user.id,
        username: req.user.username,
        action: 'PRODUCT_DELETED',
        details: `Deleted product "${productName}" (ID: ${id})`,
        timestamp: new Date(),
        targetId: id.toString(),
        targetType: 'product'
      });

      res.json({ message: "Product deleted successfully" });
    } catch (error: any) {
      console.error("Error deleting product:", error);

      // Handle database foreign key constraint errors first (most specific)
      if (error.code === '23503') {
        if (error.constraint === 'order_items_product_id_products_id_fk') {
          return res.status(409).json({ 
            message: "Cannot delete product - it has been ordered by customers and is required for order history",
            code: "PRODUCT_HAS_ORDERS",
            detail: "This product appears in customer orders and cannot be deleted to maintain order integrity"
          });
        }
        return res.status(409).json({ 
          message: "Cannot delete product - it is referenced by other data in the system",
          code: "FOREIGN_KEY_CONSTRAINT"
        });
      }

      // Handle application-level constraint checks
      if (error.message && error.message.includes("Cannot delete product that has been ordered")) {
        return res.status(409).json({ 
          message: "Cannot delete product - it has been ordered by customers",
          code: "PRODUCT_HAS_ORDERS"
        });
      }

      if (error.message && error.message.includes("Cannot delete product that is in a cart")) {
        return res.status(409).json({ 
          message: "Cannot delete product - it is currently in customer carts",
          code: "PRODUCT_IN_CART"
        });
      }

      // Handle general foreign key constraint errors
      if (error.message.includes('foreign key constraint')) {
        return res.status(409).json({ 
          message: "Cannot delete product - it is referenced by orders or other data",
          code: "FOREIGN_KEY_CONSTRAINT"
        });
      }

      // Generic server error
      res.status(500).json({ 
        message: "Failed to delete product", 
        error: error.message || "Unknown error"
      });
    }
  });

  // Get product price history - Admin version
  app.get('/api/admin/products/:id/price-history', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const id = parseInt(req.params.id);
      const priceHistory = await storage.getProductPricingHistory(id);
      res.json(priceHistory || []);
    } catch (error) {
      console.error('Error fetching price history:', error);
      res.status(500).json({ message: 'Failed to fetch price history' });
    }
  });

  // Get product price history - General version (for authenticated users)
  app.get('/api/products/:id/price-history', requireAuth, async (req: any, res) => {
    try {
      const id = parseInt(req.params.id);
      const priceHistory = await storage.getProductPricingHistory(id);
      res.json(priceHistory || []);
    } catch (error) {
      console.error('Error fetching price history:', error);
      res.status(500).json({ message: 'Failed to fetch price history' });
    }
  });

  // Duplicate endpoint removed - only one GET /api/customer/statistics remains

  // ============================================================================
  // MISSING ENDPOINTS - ADDED TO FIX ROUTING MISMATCHES
  // ============================================================================

  // Product search endpoint
  // Product search endpoint moved to consolidated section



  // Addresses endpoint moved to consolidated section



  // Admin purchase orders endpoint (alias for backward compatibility)
  app.get('/api/admin/purchase-orders', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const purchaseOrders = await storage.getAllPurchaseOrders();
      res.json(purchaseOrders);
    } catch (error) {
      console.error('Error fetching admin purchase orders:', error);
      res.status(500).json({ message: 'Failed to fetch purchase orders' });
    }
  });

  app.post('/api/admin/purchase-orders', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const purchaseOrderData = {
        ...req.body,
        createdBy: req.user.username || req.user.id,
        createdAt: new Date(),
        updatedAt: new Date()
      };
      const purchaseOrder = await storage.createPurchaseOrder(purchaseOrderData);
      res.status(201).json({ success: true, purchaseOrder });
    } catch (error) {
      console.error('Error creating admin purchase order:', error);
      res.status(500).json({ message: 'Failed to create purchase order' });
    }
  });

  app.get('/api/admin/purchase-orders/:id', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      const purchaseOrder = await storage.getPurchaseOrderById(parseInt(id));
      if (!purchaseOrder) {
        return res.status(404).json({ message: 'Purchase order not found' });
      }
      res.json(purchaseOrder);
    } catch (error) {
      console.error('Error fetching purchase order:', error);
      res.status(500).json({ message: 'Failed to fetch purchase order' });
    }
  });



  // Order settings endpoint
  app.get('/api/order-settings', requireAuth, async (req: any, res) => {
    try {
      const settings = {
        deliveryFee: 5.00,
        freeDeliveryThreshold: 100.00,
        deliveryTimeSlots: [
          '9:00 AM - 11:00 AM',
          '11:00 AM - 1:00 PM',
          '1:00 PM - 3:00 PM',
          '3:00 PM - 5:00 PM'
        ],
        orderTypes: ['delivery', 'pickup']
      };
      res.json(settings);
    } catch (error) {
      console.error('Error fetching order settings:', error);
      res.status(500).json({ message: 'Failed to fetch order settings' });
    }
  });

  // DUPLICATE REMOVED - Use customer/orders endpoint from line 613 instead

  // DUPLICATE REMOVED - Use recommendations endpoint from line 566 instead





  // Duplicate endpoint removed - only one GET /api/admin/order-settings remains

  // Duplicate endpoint removed - only one GET /api/order-settings/minimum remains

  // Duplicate PUT endpoint removed - using earlier implementation at line 966

  // Admin product images endpoint
  app.get('/api/admin/products/images', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const products = await storage.getProducts();
      const productsWithImages = products.filter((product: any) => product.imageUrl)
        .map((product: any) => ({
          id: product.id,
          name: product.name,
          imageUrl: product.imageUrl,
          sku: product.sku,
          brand: product.brand
        }));

      res.json({
        total: productsWithImages.length,
        products: productsWithImages
      });
    } catch (error) {
      console.error('Error fetching product images:', error);
      res.status(500).json({ message: 'Failed to fetch product images' });
    }
  });

  // Admin export endpoints
  app.get('/api/admin/export/inventory', requireAdmin, async (req: any, res) => {
    try {
      const products = await storage.getProducts();
      const inventoryData = products.map((product: any) => ({
        id: product.id,
        name: product.name,
        sku: product.sku,
        brand: product.brand,
        price: product.price,
        cost: product.cost,
        stock: product.stock,
        category: product.categoryId,
        lastUpdated: product.updatedAt
      }));

      res.setHeader('Content-Type', 'application/json');
      res.setHeader('Content-Disposition', 'attachment; filename="inventory-export.json"');
      res.json({
        exportDate: new Date().toISOString(),
        totalProducts: inventoryData.length,
        data: inventoryData
      });
    } catch (error) {
      console.error('Error exporting inventory:', error);
      res.status(500).json({ message: 'Failed to export inventory' });
    }
  });

  app.get('/api/admin/export/customers', requireAdmin, async (req: any, res) => {
    try {
      const customers = await storage.getAllUsers();
      const customerData = customers.map(customer => ({
        id: customer.id,
        username: customer.username,
        firstName: customer.firstName,
        lastName: customer.lastName,
        email: customer.email,
        company: customer.company,
        customerLevel: customer.customerLevel,
        createdAt: customer.createdAt,
        lastLogin: customer.lastLogin
      }));

      res.setHeader('Content-Type', 'application/json');
      res.setHeader('Content-Disposition', 'attachment; filename="customers-export.json"');
      res.json({
        exportDate: new Date().toISOString(),
        totalCustomers: customerData.length,
        data: customerData
      });
    } catch (error) {
      console.error('Error exporting customers:', error);
      res.status(500).json({ message: 'Failed to export customers' });
    }
  });



  // Customer addresses endpoint for admin/staff
  app.get('/api/admin/customers/:customerId/addresses', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const { customerId } = req.params;
      const addresses = await storage.getDeliveryAddresses(customerId);
      res.json(addresses);
    } catch (error) {
      console.error('Error fetching customer addresses:', error);
      res.status(500).json({ message: 'Failed to fetch customer addresses' });
    }
  });

  // Staff order creation endpoint
  app.post('/api/staff/orders', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const { customerId, items, deliveryAddressId, orderType, deliveryDate, deliveryTimeSlot, deliveryNote } = req.body;

      if (!customerId || !items || !items.length) {
        return res.status(400).json({ message: 'Customer ID and items are required' });
      }

      // Calculate total from items
      const total = items.reduce((sum: number, item: any) => sum + (item.price * item.quantity), 0);

      const orderData = {
        userId: customerId,
        total,
        status: 'pending',
        orderType: orderType || 'delivery',
        deliveryAddressId: deliveryAddressId || null,
        deliveryDate: deliveryDate || null,
        deliveryTimeSlot: deliveryTimeSlot || null,
        deliveryNote: deliveryNote || null,
        deliveryFee: orderType === 'delivery' ? await calculateDeliveryFee(total) : 0,
        createdBy: req.user.id // Track who created the order
      };

      const orderItems = items.map((item: any) => ({
        productId: item.productId,
        quantity: item.quantity,
        price: item.price
      }));

      const order = await storage.createOrder(orderData, orderItems);

      // Log the staff order creation
      await storage.addActivityLog({
        userId: req.user.id,
        action: 'staff_order_created',
        details: `Staff member created order #${order.id} for customer ${customerId}`,
        timestamp: new Date()
      });

      res.status(201).json(order);
    } catch (error) {
      console.error('Error creating staff order:', error);
      res.status(500).json({ message: 'Failed to create order' });
    }
  });

  // Admin backup endpoints with GET and POST methods
  app.get('/api/admin/backup', requireAdmin, async (req: any, res) => {
    try {
      const backups = await storage.getBackupList();
      res.json({ 
        success: true,
        backups,
        total: backups.length
      });
    } catch (error) {
      console.error('Error fetching backups:', error);
      res.status(500).json({ message: 'Failed to fetch backup list' });
    }
  });

  app.post('/api/admin/backup', requireAdmin, async (req: any, res) => {
    try {
      const backupResult = await```text
 storage.createBackup();
      res.json({
        success: true,
        message: 'Backup created successfully',
        backup: backupResult
      });
    } catch (error) {
      console.error('Error creating backup:', error);
      res.status(500).json({ message: 'Failed to create backup' });
    }
  });



  // Admin endpoint to view customer order history
  app.get('/api/admin/users/:userId/orders', requireAdmin, async (req: any, res) => {
    try {
      const { userId } = req.params;

      if (!userId) {
        return res.status(400).json({ message: 'User ID is required' });
      }

      const orders = await storage.getOrdersByUserId(userId);
      res.json(orders || []);
    } catch (error) {
      console.error('Error fetching customer order history:', error);
      res.status(500).json({ message: 'Failed to fetch customer order history' });
    }
  });

  // Duplicate price-history endpoint removed - using implementation at line 2477

  // Backup System Endpoints

  // Create new backup
  app.post('/api/admin/backup/create-new', requireAdmin, async (req: any, res) => {
    try {
      const backupResult = await storage.createBackup();
      res.json(backupResult);
    } catch (error) {
      console.error('Error creating backup:', error);
      res.status(500).json({ message: 'Failed to create backup' });
    }
  });

  // List all backups
  app.get('/api/admin/backup/list', requireAdmin, async (req: any, res) => {
    try {
      const backups = await storage.getBackupList();
      res.json({ backups });
    } catch (error) {
      console.error('Error listing backups:', error);
      res.status(500).json({ message: 'Failed to list backups' });
    }
  });

  // Download backup file
  app.get('/api/admin/backup/download/:filename', requireAdmin, async (req: any, res) => {
    try {
      const { filename } = req.params;
      const filePath = await storage.getBackupFilePath(filename);

      if (!filePath) {
        return res.status(404).json({ message: 'Backup file not found' });
      }

      res.download(filePath, filename);
    } catch (error) {
      console.error('Error downloading backup:', error);
      res.status(500).json({ message: 'Failed to download backup' });
    }
  });

  // Delete backup file
  app.delete('/api/admin/backup/:filename', requireAdmin, async (req: any, res) => {
    try {
      const { filename } = req.params;
      await storage.deleteBackup(filename);
      res.json({ message: 'Backup deleted successfully' });
    } catch (error) {
      console.error('Error deleting backup:', error);
      res.status(500).json({ message: 'Failed to delete backup' });
    }
  });

  // Restore from backup
  app.post('/api/admin/restore', requireAdmin, async (req: any, res) => {
    try {
      const { filename } = req.body;
      if (!filename) {
        return res.status(400).json({ message: 'Backup filename is required' });
      }

      const restoreResult = await storage.restoreFromBackup(filename);
      res.json(restoreResult);
    } catch (error) {
      console.error('Error restoring backup:', error);
      res.status(500).json({ message: 'Failed to restore backup' });
    }
  });



  // Product image upload endpoint
  app.post('/api/admin/products/:id/upload-image', requireEmployeeOrAdmin, upload.single('image'), async (req: any, res) => {
    try {
      const productId = parseInt(req.params.id);

      if (!req.file) {
        return res.status(400).json({ message: 'No image file provided' });
      }

      const imageUrl = `/uploads/${req.file.filename}`;
      console.log(`Uploading image for product ${productId}: ${imageUrl}`);

      const updatedProduct = await storage.updateProduct(productId, { imageUrl });

      if (!updatedProduct) {
        fs.unlink(req.file.path, (err) => {
          if (err) console.error('Error deleting uploaded file:', err);
        });
        return res.status(404).json({ message: 'Product not found' });
      }

      // Log image upload activity
      await storage.addActivityLog({
        userId: req.user.id,
        username: req.user.username,
        action: 'PRODUCT_IMAGE_UPLOADED',
        details: `Uploaded new image for product "${updatedProduct.name}" (ID: ${productId}) - File: ${req.file.filename}`,
        timestamp: new Date(),
        targetId: productId.toString(),
        targetType: 'product'
      });

      res.json({ 
        success: true, 
        imageUrl,
        product: updatedProduct,
        message: 'Image uploaded successfully'
      });
    } catch (error) {
      console.error('Error uploading product image:', error);

      if (req.file) {
        fs.unlink(req.file.path, (err) => {
          if (err) console.error('Error deleting uploaded file:', err);
        });
      }

      res.status(500).json({ message: 'Failed to upload image' });
    }
  });

  // Product image URL update endpoint
  app.put('/api/admin/products/:id/image', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const productId = parseInt(req.params.id);
      const { imageUrl } = req.body;

      if (!imageUrl) {
        return res.status(400).json({ message: 'Image URL is required' });
      }

      console.log(`Updating product ${productId} image URL to: ${imageUrl}`);

      const updatedProduct = await storage.updateProduct(productId, { imageUrl });

      if (!updatedProduct) {
        return res.status(404).json({ message: 'Product not found' });
      }

      // Log image URL update activity
      await storage.addActivityLog({
        userId: req.user.id,
        username: req.user.username,
        action: 'PRODUCT_IMAGE_URL_UPDATED',
        details: `Updated image URL for product "${updatedProduct.name}" (ID: ${productId}) - New URL: ${imageUrl}`,
        timestamp: new Date(),
        targetId: productId.toString(),
        targetType: 'product'
      });

      res.json({ 
        success: true, 
        product: updatedProduct,
        message: 'Image URL updated successfully'
      });
    } catch (error) {
      console.error('Error updating product image URL:', error);
      res.status(500).json({ message: 'Failed to update image URL' });
    }
  });

  // ============================================================================
  // PUSH NOTIFICATION DEVICE TOKEN MANAGEMENT ENDPOINTS
  // ============================================================================

  // Register device token for push notifications
  app.post('/api/push-notifications/register', requireAuth, async (req: any, res) => {
    try {
      const { token, platform, deviceInfo } = req.body;
      const userId = req.user.id;

      if (!token || !platform) {
        return res.status(400).json({ message: 'Token and platform are required' });
      }

      const deviceToken = await storage.registerDeviceToken(userId, token, platform, deviceInfo);
      res.json({ success: true, deviceToken });
    } catch (error) {
      console.error('Error registering device token:', error);
      res.status(500).json({ message: 'Failed to register device token' });
    }
  });

  // Remove device token
  app.delete('/api/push-notifications/tokens/:token', requireAuth, async (req: any, res) => {
    try {
      const { token } = req.params;
      const userId = req.user.id;

      await storage.removeDeviceToken(userId, token);
      res.json({ success: true });
    } catch (error) {
      console.error('Error removing device token:', error);
      res.status(500).json({ message: 'Failed to remove device token' });
    }
  });

  // Get user's device tokens
  app.get('/api/push-notifications/tokens', requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const tokens = await storage.getUserDeviceTokens(userId);
      res.json(tokens);
    } catch (error) {
      console.error('Error fetching device tokens:', error);
      res.status(500).json({ message: 'Failed to fetch device tokens' });
    }
  });

  // Get push notification settings
  app.get('/api/push-notifications/settings', requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const settings = await storage.getPushNotificationSettings(userId);
      res.json(settings || {
        orderUpdates: true,
        promotions: true,
        systemNotifications: true,
        lowStockAlerts: req.user.isAdmin || req.user.isEmployee
      });
    } catch (error) {
      console.error('Error fetching push notification settings:', error);
      res.status(500).json({ message: 'Failed to fetch push notification settings' });
    }
  });

  // Update push notification settings
  app.put('/api/push-notifications/settings', requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const settings = req.body;

      const updatedSettings = await storage.updatePushNotificationSettings(userId, settings);
      res.json(updatedSettings);
    } catch (error) {
      console.error('Error updating push notification settings:', error);
      res.status(500).json({ message: 'Failed to update push notification settings' });
    }
  });

  // Admin endpoint to send test notification
  app.post('/api/push-notifications/test', requireAdmin, async (req: any, res) => {
    try {
      const { userId, title, message, type } = req.body;

      if (!userId || !title || !message) {
        return res.status(400).json({ message: 'UserId, title, and message are required' });
      }

      await pushNotificationService.sendToUser(userId, {
        title,
        body: message,
        icon: '/favicon.ico',
        data: {
          type: type || 'test',
          url: '/dashboard'
        }
      });

      res.json({ success: true, message: 'Test notification sent' });
    } catch (error) {
      console.error('Error sending test notification:', error);
      res.status(500).json({ message: 'Failed to send test notification' });
    }
  });

  // Admin endpoint to send bulk notifications
  app.post('/api/push-notifications/broadcast', requireAdmin, async (req: any, res) => {
    try {
      const { title, message, targetRole, data } = req.body;

      if (!title || !message) {
        return res.status(400).json({ message: 'Title and message are required' });
      }

      const payload = {
        title,
        body: message,
        icon: '/favicon.ico',
        data: data || { type: 'broadcast', url: '/dashboard' }
      };

      switch (targetRole) {
        case 'admin':
          await pushNotificationService.sendToAllAdmins(payload);
          break;
        case 'staff':
          await pushNotificationService.sendToAllStaff(payload);
          break;
        case 'customer':
          await pushNotificationService.sendToUsersByRole('customer', payload);
          break;
        default:
          // Send to all users
          const users = await storage.getAllUsers();
          const promises = users.map(user => pushNotificationService.sendToUser(user.id, payload));
          await Promise.allSettled(promises);
      }

      res.json({ success: true, message: 'Broadcast notification sent' });
    } catch (error) {
      console.error('Error sending broadcast notification:', error);
      res.status(500).json({ message: 'Failed to send broadcast notification' });
    }
  });

  // Missing endpoints to fix frontend-backend mismatches

  // Cart clear endpoint
  app.delete('/api/cart/clear', requireAuth, async (req: any, res) => {
    try {
      await storage.clearUserCart(req.user.id);
      res.json({ message: 'Cart cleared successfully' });
    } catch (error) {
      console.error('Error clearing cart:', error);
      res.status(500).json({ message: 'Failed to clear cart' });
    }
  });

  // Admin clear global cart endpoint
  app.delete('/api/admin/clear-global-cart', requireAdmin, async (req: any, res) => {
    try {
      await storage.clearAllCarts();
      res.json({ message: 'All carts cleared successfully' });
    } catch (error) {
      console.error('Error clearing all carts:', error);
      res.status(500).json({ message: 'Failed to clear all carts' });
    }
  });

  // Notification read status endpoints
  app.patch('/api/notifications/:notificationId/read', requireAuth, async (req: any, res) => {
    try {
      const { notificationId } = req.params;
      await storage.markNotificationAsRead(notificationId, req.user.id);
      res.json({ message: 'Notification marked as read' });
    } catch (error) {
      console.error('Error marking notification as read:', error);
      res.status(500).json({ message: 'Failed to mark notification as read' });
    }
  });

  app.delete('/api/notifications/:notificationId', requireAuth, async (req: any, res) => {
    try {
      const { notificationId } = req.params;
      await storage.deleteNotification(notificationId, req.user.id);
      res.json({ message: 'Notification deleted successfully' });
    } catch (error) {
      console.error('Error deleting notification:', error);
      res.status(500).json({ message: 'Failed to delete notification' });
    }
  });

  // Delivery address endpoints
  app.get('/api/delivery-addresses/:id', requireAuth, async (req: any, res) => {
    try {
      const { id } = req.params;
      const address = await storage.getDeliveryAddress(parseInt(id));
      if (!address) {
        return res.status(404).json({ message: 'Address not found' });
      }
      res.json(address);
    } catch (error) {
      console.error('Error fetching address:', error);
      res.status(500).json({ message: 'Failed to fetch address' });
    }
  });

  app.put('/api/delivery-addresses/:id', requireAuth, async (req: any, res) => {
    try {
      const { id } = req.params;
      const updatedAddress = await storage.updateDeliveryAddress(parseInt(id), req.body);
      res.json(updatedAddress);
    } catch (error) {
      console.error('Error updating address:', error);
      res.status(500).json({ message: 'Failed to update address' });
    }
  });

  app.delete('/api/delivery-addresses/:id', requireAuth, async (req: any, res) => {
    try {
      const { id } = req.params;
      await storage.deleteDeliveryAddress(parseInt(id));
      res.json({ message: 'Address deleted successfully' });
    } catch (error) {
      console.error('Error deleting address:', error);
      res.status(500).json({ message: 'Failed to delete address' });
    }
  });

  app.post('/api/delivery-addresses/:id/set-default', requireAuth, async (req: any, res) => {
    try {
      const { id } = req.params;
      await storage.setDefaultDeliveryAddress(parseInt(id), req.user.id);
      res.json({ message: 'Default address set successfully' });
    } catch (error) {
      console.error('Error setting default address:', error);
      res.status(500).json({ message: 'Failed to set default address' });
    }
  });

  // Order notes endpoints
  app.get('/api/orders/:orderId/notes', requireAuth, async (req: any, res) => {
    try {
      const { orderId } = req.params;
      const notes = await storage.getOrderNotes(parseInt(orderId));
      res.json(notes);
    } catch (error) {
      console.error('Error fetching order notes:', error);
      res.status(500).json({ message: 'Failed to fetch order notes' });
    }
  });

  app.post('/api/orders/:orderId/notes', requireAuth, async (req: any, res) => {
    try {
      const { orderId } = req.params;
      const { note, notifyCustomer } = req.body;

      const orderNote = await storage.addOrderNote(parseInt(orderId), req.body, req.user.id);

      // Check if this is a customer adding a note (not staff/admin)
      const isCustomerNote = !req.user.isAdmin && !req.user.isEmployee;

      if (isCustomerNote) {
        // Send push notification to staff when customer adds a note
        try {
          const customerName = req.user.username || req.user.firstName || 'Customer';
          await pushNotificationService.notifyCustomerNote(
            parseInt(orderId),
            customerName,
            note
          );
          console.log(`Push notification sent to staff for customer note on order #${orderId}`);
        } catch (notificationError) {
          console.error('Failed to send push notification for customer note:', notificationError);
          // Don't fail the note creation if notification fails
        }
      }

      res.json(orderNote);
    } catch (error) {
      console.error('Error adding order note:', error);
      res.status(500).json({ message: 'Failed to add order note' });
    }
  });

  app.delete('/api/orders/:orderId/notes/:noteId', requireAuth, async (req: any, res) => {
    try {
      const { noteId } = req.params;
      await storage.deleteOrderNote(parseInt(noteId));
      res.json({ message: 'Note deleted successfully' });
    } catch (error) {
      console.error('Error deleting order note:', error);
      res.status(500).json({ message: 'Failed to delete note' });
    }
  });

  // Order items endpoints
  app.post('/api/orders/:orderId/items', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const { orderId } = req.params;
      const item = await storage.addOrderItem(parseInt(orderId), req.body);
      res.json(item);
    } catch (error) {
      console.error('Error adding order item:', error);
      res.status(500).json({ message: 'Failed to add order item' });
    }
  });

  app.put('/api/orders/:orderId/items/:itemId', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const { itemId } = req.params;
      const updatedItem = await storage.updateOrderItem(parseInt(itemId), req.body);
      res.json(updatedItem);
    } catch (error) {
      console.error('Error updating order item:', error);
      res.status(500).json({ message: 'Failed to update order item' });
    }
  });

  // Order completion endpoint
  app.post('/api/orders/:id/complete', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      const completedOrder = await storage.completeOrder(parseInt(id), req.body);
      res.json(completedOrder);
    } catch (error) {
      console.error('Error completing order:', error);
      res.status(500).json({ message: 'Failed to complete order' });
    }
  });

  // Product search endpoint
  app.get('/api/products/search', async (req: any, res) => {
    try {
      const { q } = req.query;
      if (!q) {
        return res.status(400).json({ message: 'Search query is required' });
      }
      const products = await storage.searchProducts(q.toString());
      res.json(products);
    } catch (error) {
      console.error('Error searching products:', error);
      res.status(500).json({ message: 'Failed to search products' });
    }
  });

  // Addresses endpoint
  app.get('/api/addresses', requireAuth, async (req: any, res) => {
    try {
      const addresses = await storage.getUserDeliveryAddresses(req.user.id);
      res.json(addresses);
    } catch (error) {
      console.error('Error fetching addresses:', error);
      res.status(500).json({ message: 'Failed to fetch addresses' });
    }
  });

  // Recent orders endpoint
  app.get('/api/orders/recent', requireAuth, async (req: any, res) => {
    try {
      const limit = parseInt(req.query.limit?.toString() || '10');
      const orders = await storage.getRecentOrders(req.user.id, limit);
      res.json(orders);
    } catch (error) {
      console.error('Error fetching recent orders:', error);
      res.status(500).json({ message: 'Failed to fetch recent orders' });
    }
  });

  // 404 handler for API routes
  app.use('/api/*', (req, res) => {
    res.status(404).json({ message: 'API endpoint not found' });
  });

  // Import and register all route modules
  const authRoutes = await import('./routes/auth');
  const cartRoutes = await import('./routes/cart');
  const notificationRoutes = await import('./routes/notification');

  app.use("/api", authRoutes.default);
  app.use("/api", cartRoutes.default);
  app.use("/api", notificationRoutes.default);

  // Import invoice processor and purchase orders routes
  const invoiceProcessorRoutes = await import('./routes/invoice-processor');
  const purchaseOrderRoutes = await import('./routes/purchase-orders');

  app.use("/api", invoiceProcessorRoutes.default);
  app.use("/api", purchaseOrderRoutes.default);

  const httpServer = createServer(app);
  return httpServer;
}
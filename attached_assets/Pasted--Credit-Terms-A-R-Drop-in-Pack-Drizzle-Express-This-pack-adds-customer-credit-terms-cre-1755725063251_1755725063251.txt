# Credit Terms & A/R – Drop‑in Pack (Drizzle + Express)

This pack adds **customer credit terms, credit limits, aging, invoices, payments, and enforcement at order placement**. It’s designed to drop into your Node/Express + PostgreSQL + Drizzle stack.

> Copy the files as‑is, then run the migration. Paths shown are suggestions—adjust imports to match your repo.

---

## 0) What you get

* Customer fields: `term`, `credit_limit_cents`, `on_credit_hold`, computed `exposure` via queries
* Tables: `ar_invoices`, `ar_invoice_lines`, `ar_payments`, `ar_payment_apps`
* Endpoints: `/ar/terms`, `/ar/summary/:customerId`, `/ar/aging`, `/ar/invoices`, `/ar/payments`
* Enforcement: middleware that blocks new orders when exposure > limit (with manager override hook)
* Oldest‑invoice autopay application when no explicit allocations are provided

---

## 1) SQL migration

Create **`migrations/20250820_credit_ar.sql`**

```sql
-- Customers: add credit fields (safe to re-run)
ALTER TABLE IF EXISTS customers
  ADD COLUMN IF NOT EXISTS term VARCHAR(16) DEFAULT 'Prepaid' NOT NULL,
  ADD COLUMN IF NOT EXISTS credit_limit_cents BIGINT DEFAULT 0 NOT NULL,
  ADD COLUMN IF NOT EXISTS on_credit_hold BOOLEAN DEFAULT FALSE NOT NULL;

-- Invoices
CREATE TABLE IF NOT EXISTS ar_invoices (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  customer_id UUID NOT NULL,
  order_id UUID,
  invoice_no VARCHAR(32) UNIQUE,
  status VARCHAR(16) NOT NULL DEFAULT 'open', -- draft|open|paid|void
  issue_date DATE NOT NULL DEFAULT CURRENT_DATE,
  due_date DATE,
  subtotal_cents BIGINT NOT NULL DEFAULT 0,
  tax_cents BIGINT NOT NULL DEFAULT 0,
  total_cents BIGINT NOT NULL DEFAULT 0,
  balance_cents BIGINT NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE INDEX IF NOT EXISTS idx_ar_inv_customer ON ar_invoices(customer_id);
CREATE INDEX IF NOT EXISTS idx_ar_inv_status ON ar_invoices(status);

-- Invoice lines
CREATE TABLE IF NOT EXISTS ar_invoice_lines (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  invoice_id UUID NOT NULL REFERENCES ar_invoices(id) ON DELETE CASCADE,
  sku VARCHAR(64),
  description TEXT,
  uom VARCHAR(16),
  quantity NUMERIC(18,3) NOT NULL DEFAULT 1,
  unit_price_cents BIGINT NOT NULL DEFAULT 0,
  line_subtotal_cents BIGINT NOT NULL DEFAULT 0,
  tax_cents BIGINT NOT NULL DEFAULT 0,
  total_cents BIGINT NOT NULL DEFAULT 0
);
CREATE INDEX IF NOT EXISTS idx_ar_lines_invoice ON ar_invoice_lines(invoice_id);

-- Payments (header)
CREATE TABLE IF NOT EXISTS ar_payments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  customer_id UUID NOT NULL,
  received_at DATE NOT NULL DEFAULT CURRENT_DATE,
  method VARCHAR(24) NOT NULL, -- cash|check|ach|card|adjustment
  reference VARCHAR(64), -- check #, txn id
  amount_cents BIGINT NOT NULL,
  unapplied_cents BIGINT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE INDEX IF NOT EXISTS idx_ar_pmt_customer ON ar_payments(customer_id);

-- Payment applications (many-to-many)
CREATE TABLE IF NOT EXISTS ar_payment_apps (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  payment_id UUID NOT NULL REFERENCES ar_payments(id) ON DELETE CASCADE,
  invoice_id UUID NOT NULL REFERENCES ar_invoices(id) ON DELETE CASCADE,
  amount_cents BIGINT NOT NULL
);
CREATE INDEX IF NOT EXISTS idx_ar_app_invoice ON ar_payment_apps(invoice_id);
CREATE INDEX IF NOT EXISTS idx_ar_app_payment ON ar_payment_apps(payment_id);

-- Trigger to keep ar_invoices.balance_cents in sync
CREATE OR REPLACE FUNCTION trg_ar_invoice_update_balance() RETURNS TRIGGER AS $$
BEGIN
  -- Recompute balance from total minus applied payments
  UPDATE ar_invoices ai SET
    balance_cents = ai.total_cents - COALESCE((
      SELECT SUM(apa.amount_cents) FROM ar_payment_apps apa WHERE apa.invoice_id = ai.id
    ), 0),
    status = CASE
      WHEN ai.status = 'void' THEN 'void'
      WHEN (ai.total_cents - COALESCE((SELECT SUM(apa.amount_cents) FROM ar_payment_apps apa WHERE apa.invoice_id = ai.id), 0)) <= 0 THEN 'paid'
      ELSE 'open'
    END,
    updated_at = NOW()
  WHERE ai.id = NEW.invoice_id;
  RETURN NULL;
END;$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_after_payment_app ON ar_payment_apps;
CREATE TRIGGER trg_after_payment_app
AFTER INSERT OR UPDATE OR DELETE ON ar_payment_apps
FOR EACH ROW EXECUTE FUNCTION trg_ar_invoice_update_balance();
```

> If your schema/database uses a different extension for UUID generation, add `CREATE EXTENSION IF NOT EXISTS pgcrypto;` (or use `uuid-ossp`).

---

## 2) Drizzle schema

Create **`server/src/db/schema.ar.ts`**

```ts
import { pgTable, uuid, varchar, date, bigint, timestamp, text, numeric, boolean, index } from 'drizzle-orm/pg-core';

export const customersCreditPatch = pgTable('customers', {
  id: uuid('id').primaryKey(), // reuse existing pk
  term: varchar('term', { length: 16 }).default('Prepaid').notNull(),
  creditLimitCents: bigint('credit_limit_cents', { mode: 'number' }).default(0).notNull(),
  onCreditHold: boolean('on_credit_hold').default(false).notNull(),
});

export const arInvoices = pgTable('ar_invoices', {
  id: uuid('id').defaultRandom().primaryKey(),
  customerId: uuid('customer_id').notNull(),
  orderId: uuid('order_id'),
  invoiceNo: varchar('invoice_no', { length: 32 }),
  status: varchar('status', { length: 16 }).default('open').notNull(),
  issueDate: date('issue_date').defaultNow().notNull(),
  dueDate: date('due_date'),
  subtotalCents: bigint('subtotal_cents', { mode: 'number' }).default(0).notNull(),
  taxCents: bigint('tax_cents', { mode: 'number' }).default(0).notNull(),
  totalCents: bigint('total_cents', { mode: 'number' }).default(0).notNull(),
  balanceCents: bigint('balance_cents', { mode: 'number' }).default(0).notNull(),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
});

export const arInvoiceLines = pgTable('ar_invoice_lines', {
  id: uuid('id').defaultRandom().primaryKey(),
  invoiceId: uuid('invoice_id').notNull(),
  sku: varchar('sku', { length: 64 }),
  description: text('description'),
  uom: varchar('uom', { length: 16 }),
  quantity: numeric('quantity', { precision: 18, scale: 3 }).default('1').notNull(),
  unitPriceCents: bigint('unit_price_cents', { mode: 'number' }).default(0).notNull(),
  lineSubtotalCents: bigint('line_subtotal_cents', { mode: 'number' }).default(0).notNull(),
  taxCents: bigint('tax_cents', { mode: 'number' }).default(0).notNull(),
  totalCents: bigint('total_cents', { mode: 'number' }).default(0).notNull(),
});

export const arPayments = pgTable('ar_payments', {
  id: uuid('id').defaultRandom().primaryKey(),
  customerId: uuid('customer_id').notNull(),
  receivedAt: date('received_at').defaultNow().notNull(),
  method: varchar('method', { length: 24 }).notNull(),
  reference: varchar('reference', { length: 64 }),
  amountCents: bigint('amount_cents', { mode: 'number' }).notNull(),
  unappliedCents: bigint('unapplied_cents', { mode: 'number' }).notNull(),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
});

export const arPaymentApps = pgTable('ar_payment_apps', {
  id: uuid('id').defaultRandom().primaryKey(),
  paymentId: uuid('payment_id').notNull(),
  invoiceId: uuid('invoice_id').notNull(),
  amountCents: bigint('amount_cents', { mode: 'number' }).notNull(),
});
```

> If you already have a `customers` schema file, keep that as source of truth; the `customersCreditPatch` above only exists so Drizzle can select the new fields.

---

## 3) AR service (pricing‑agnostic)

Create **`server/src/modules/ar/ar.service.ts`**

```ts
import { and, desc, eq, gt, lte, sql } from 'drizzle-orm';
import { db } from '../../db/client'; // adjust path
import { arInvoices, arInvoiceLines, arPayments, arPaymentApps } from '../../db/schema.ar';

export type Term = 'Prepaid' | 'Net7' | 'Net15' | 'Net30' | 'Net45';

export function termToDays(term: Term): number {
  switch (term) {
    case 'Net7': return 7; case 'Net15': return 15; case 'Net30': return 30; case 'Net45': return 45; default: return 0;
  }
}

export async function customerExposureCents(customerId: string): Promise<number> {
  const [{ open }] = await db.execute(sql`SELECT COALESCE(SUM(balance_cents),0) AS open FROM ar_invoices WHERE customer_id = ${customerId} AND status IN ('open')`);
  return Number(open || 0);
}

export async function agingBuckets(customerId?: string) {
  // Buckets: 0-30, 31-60, 61-90, 90+
  const res = await db.execute(sql`
    SELECT customer_id,
      SUM(CASE WHEN CURRENT_DATE - due_date <= 30 THEN balance_cents ELSE 0 END) AS b0_30,
      SUM(CASE WHEN CURRENT_DATE - due_date BETWEEN 31 AND 60 THEN balance_cents ELSE 0 END) AS b31_60,
      SUM(CASE WHEN CURRENT_DATE - due_date BETWEEN 61 AND 90 THEN balance_cents ELSE 0 END) AS b61_90,
      SUM(CASE WHEN CURRENT_DATE - due_date > 90 THEN balance_cents ELSE 0 END) AS b90p
    FROM ar_invoices
    WHERE status = 'open' AND due_date IS NOT NULL
      ${customerId ? sql`AND customer_id = ${customerId}` : sql``}
    GROUP BY customer_id
  `);
  return res.rows;
}

export async function createInvoice(input: {
  customerId: string;
  orderId?: string;
  invoiceNo?: string;
  issueDate?: string; // YYYY-MM-DD
  dueDate?: string;   // YYYY-MM-DD
  lines: Array<{ sku?: string; description: string; uom?: string; quantity: number; unitPriceCents: number; taxCents?: number }>;
}) {
  const subtotal = input.lines.reduce((s, l) => s + Math.round(l.quantity * l.unitPriceCents), 0);
  const lineTaxes = input.lines.reduce((s, l) => s + (l.taxCents || 0), 0);
  const total = subtotal + lineTaxes;

  const [inv] = await db.insert(arInvoices).values({
    customerId: input.customerId,
    orderId: input.orderId,
    invoiceNo: input.invoiceNo,
    issueDate: input.issueDate ? new Date(input.issueDate) : undefined,
    dueDate: input.dueDate ? new Date(input.dueDate) : undefined,
    subtotalCents: subtotal,
    taxCents: lineTaxes,
    totalCents: total,
    balanceCents: total,
  }).returning();

  await db.insert(arInvoiceLines).values(input.lines.map(l => ({
    invoiceId: inv.id,
    sku: l.sku,
    description: l.description,
    uom: l.uom,
    quantity: String(l.quantity),
    unitPriceCents: l.unitPriceCents,
    lineSubtotalCents: Math.round(l.quantity * l.unitPriceCents),
    taxCents: l.taxCents || 0,
    totalCents: Math.round(l.quantity * l.unitPriceCents) + (l.taxCents || 0),
  })));

  // Trigger will set balance/status; return invoice
  const [fresh] = await db.select().from(arInvoices).where(eq(arInvoices.id, inv.id));
  return fresh;
}

export async function recordPayment(input: {
  customerId: string;
  amountCents: number;
  method: 'cash'|'check'|'ach'|'card'|'adjustment';
  reference?: string;
  allocations?: Array<{ invoiceId: string; amountCents: number }>; // if omitted, auto-apply oldest first
}) {
  const [pmt] = await db.insert(arPayments).values({
    customerId: input.customerId,
    method: input.method,
    reference: input.reference,
    amountCents: input.amountCents,
    unappliedCents: input.amountCents,
  }).returning();

  if (input.allocations && input.allocations.length) {
    for (const a of input.allocations) {
      await applyToInvoice(pmt.id, a.invoiceId, a.amountCents);
    }
  } else {
    await autoApplyOldest(pmt.id);
  }

  return pmt;
}

export async function applyToInvoice(paymentId: string, invoiceId: string, amountCents: number) {
  if (amountCents <= 0) return;
  // Load payment
  const [p] = await db.select().from(arPayments).where(eq(arPayments.id, paymentId));
  if (!p) throw new Error('payment not found');
  if (p.unappliedCents < amountCents) throw new Error('insufficient unapplied amount');

  // Load invoice
  const [inv] = await db.select().from(arInvoices).where(eq(arInvoices.id, invoiceId));
  if (!inv) throw new Error('invoice not found');
  const remaining = Math.max(0, inv.totalCents - (inv.totalCents - inv.balanceCents));
  const toApply = Math.min(amountCents, inv.balanceCents);

  if (toApply <= 0) return;

  await db.insert(arPaymentApps).values({ paymentId, invoiceId, amountCents: toApply });
  await db.update(arPayments).set({ unappliedCents: p.unappliedCents - toApply }).where(eq(arPayments.id, paymentId));
}

export async function autoApplyOldest(paymentId: string) {
  // Apply to oldest open invoices for that payment's customer
  const [p] = await db.select().from(arPayments).where(eq(arPayments.id, paymentId));
  if (!p) throw new Error('payment not found');

  let remaining = p.unappliedCents;
  if (remaining <= 0) return;

  const open = await db.select().from(arInvoices)
    .where(and(eq(arInvoices.customerId, p.customerId), eq(arInvoices.status, 'open')))
    .orderBy(desc(arInvoices.issueDate));

  for (const inv of open) {
    if (remaining <= 0) break;
    const apply = Math.min(remaining, inv.balanceCents);
    if (apply > 0) {
      await applyToInvoice(paymentId, inv.id, apply);
      remaining -= apply;
    }
  }
}
```

---

## 4) API router

Create **`server/src/modules/ar/ar.router.ts`**

```ts
import { Router } from 'express';
import { z } from 'zod';
import { db } from '../../db/client'; // adjust path
import { customersCreditPatch, arInvoices } from '../../db/schema.ar';
import { createInvoice, recordPayment, customerExposureCents, agingBuckets, termToDays } from './ar.service';
import { eq, sql } from 'drizzle-orm';

const r = Router();

const setTermsSchema = z.object({
  customerId: z.string().uuid(),
  term: z.enum(['Prepaid','Net7','Net15','Net30','Net45']),
  creditLimitCents: z.number().int().min(0),
  onCreditHold: z.boolean().optional(),
});

r.post('/terms', async (req, res) => {
  const p = setTermsSchema.safeParse(req.body);
  if (!p.success) return res.status(400).json({ error: 'invalid payload' });
  const { customerId, term, creditLimitCents, onCreditHold } = p.data;

  await db.execute(sql`UPDATE customers SET term = ${term}, credit_limit_cents = ${creditLimitCents}, on_credit_hold = COALESCE(${onCreditHold}, on_credit_hold) WHERE id = ${customerId}`);
  return res.json({ ok: true });
});

r.get('/summary/:customerId', async (req, res) => {
  const customerId = req.params.customerId;
  const exposure = await customerExposureCents(customerId);

  const inv = await db.execute(sql`SELECT id, invoice_no, issue_date, due_date, total_cents, balance_cents, status FROM ar_invoices WHERE customer_id = ${customerId} ORDER BY issue_date DESC LIMIT 50`);
  const pmt = await db.execute(sql`SELECT id, received_at, method, reference, amount_cents, unapplied_cents FROM ar_payments WHERE customer_id = ${customerId} ORDER BY created_at DESC LIMIT 50`);

  return res.json({ exposureCents: exposure, invoices: inv.rows, payments: pmt.rows });
});

r.get('/aging', async (req, res) => {
  const customerId = req.query.customerId as string | undefined;
  const rows = await agingBuckets(customerId);
  return res.json({ rows });
});

const invoiceSchema = z.object({
  customerId: z.string().uuid(),
  orderId: z.string().uuid().optional(),
  invoiceNo: z.string().max(32).optional(),
  issueDate: z.string().date().optional(),
  term: z.enum(['Prepaid','Net7','Net15','Net30','Net45']).optional(),
  lines: z.array(z.object({ sku: z.string().optional(), description: z.string(), uom: z.string().optional(), quantity: z.number().positive(), unitPriceCents: z.number().int().nonnegative(), taxCents: z.number().int().nonnegative().optional() })).min(1),
});

r.post('/invoices', async (req, res) => {
  const p = invoiceSchema.safeParse(req.body);
  if (!p.success) return res.status(400).json({ error: 'invalid payload' });
  const { customerId, orderId, invoiceNo, issueDate, term, lines } = p.data;

  let dueDate: string | undefined = undefined;
  if (term && term !== 'Prepaid') {
    const days = termToDays(term as any);
    const base = issueDate ? new Date(issueDate) : new Date();
    const due = new Date(base.getTime());
    due.setDate(due.getDate() + days);
    dueDate = due.toISOString().slice(0,10);
  }

  const inv = await createInvoice({ customerId, orderId, invoiceNo, issueDate, dueDate, lines });
  return res.json(inv);
});

const paymentSchema = z.object({
  customerId: z.string().uuid(),
  method: z.enum(['cash','check','ach','card','adjustment']),
  reference: z.string().optional(),
  amountCents: z.number().int().positive(),
  allocations: z.array(z.object({ invoiceId: z.string().uuid(), amountCents: z.number().int().positive() })).optional(),
});

r.post('/payments', async (req, res) => {
  const p = paymentSchema.safeParse(req.body);
  if (!p.success) return res.status(400).json({ error: 'invalid payload' });
  const pay = await recordPayment(p.data);
  return res.json(pay);
});

export default r;
```

Wire it in **`server/src/app.ts`** (or wherever you mount routers):

```ts
import arRouter from './modules/ar/ar.router';
app.use('/ar', arRouter);
```

---

## 5) Credit enforcement on order placement

Create **`server/src/modules/ar/credit.middleware.ts`**

```ts
import { db } from '../../db/client';
import { customerExposureCents } from './ar.service';
import { sql } from 'drizzle-orm';

/**
 * Blocks orders if: on_credit_hold OR (exposure + orderTotal > credit_limit)
 * Set req.allowOverride = true upstream to bypass (e.g., admin override).
 */
export async function enforceCredit(req: any, res: any, next: any) {
  try {
    const customerId: string = req.body.customerId || req.params.customerId;
    const orderTotalCents: number = Number(req.body.totalCents || 0);
    if (!customerId) return res.status(400).json({ error: 'missing customerId' });

    const { rows } = await db.execute(sql`SELECT term, credit_limit_cents, on_credit_hold FROM customers WHERE id = ${customerId}`);
    if (!rows.length) return res.status(404).json({ error: 'customer not found' });

    const { term, credit_limit_cents, on_credit_hold } = rows[0] as any;
    if (term === 'Prepaid') return next(); // prepaid customers do not use credit
    if (on_credit_hold && !req.allowOverride) return res.status(402).json({ error: 'Customer on credit hold' });

    const exposure = await customerExposureCents(customerId);
    const allowed = Number(credit_limit_cents) - exposure;

    if (orderTotalCents > allowed && !req.allowOverride) {
      return res.status(402).json({
        error: 'Credit limit exceeded',
        detail: { exposureCents: exposure, creditLimitCents: Number(credit_limit_cents), orderTotalCents }
      });
    }

    return next();
  } catch (e) {
    console.error('enforceCredit error', e);
    return res.status(500).json({ error: 'internal error' });
  }
}
```

Patch your **order** route (example):

```ts
import { enforceCredit } from '../ar/credit.middleware';

ordersRouter.post('/', enforceCredit, async (req, res) => {
  // create order... if payment = terms, later create invoice on shipment
});
```

---

## 6) Minimal admin UI hooks (optional, quick win)

Add to Admin > Customer detail:

* Show: `term`, `credit_limit_cents`, `on_credit_hold`, `exposure` (fetch `/ar/summary/:customerId`)
* Actions: Update terms (POST `/ar/terms`), toggle hold, view latest invoices/payments

---

## 7) Quick test plan

1. Set terms & limit

```bash
curl -X POST http://localhost:5000/ar/terms \
 -H 'Content-Type: application/json' \
 -d '{"customerId":"<uuid>","term":"Net30","creditLimitCents":500000}'
```

2. Create invoice

```bash
curl -X POST http://localhost:5000/ar/invoices \
 -H 'Content-Type: application/json' \
 -d '{"customerId":"<uuid>","invoiceNo":"INV-1001","term":"Net30","lines":[{"description":"Pallet of Energy Drink","quantity":10,"unitPriceCents":2500}]}'
```

3. Check summary

```bash
curl http://localhost:5000/ar/summary/<uuid>
```

4. Record payment (auto-apply)

```bash
curl -X POST http://localhost:5000/ar/payments \
 -H 'Content-Type: application/json' \
 -d '{"customerId":"<uuid>","method":"ach","amountCents":100000}'
```

5. Place order over limit → should block

* POST `/orders` with `totalCents` greater than remaining credit → expect 402 with details.

---

## 8) Notes & integration tips

* If you already have an **invoices** concept, you can map to it by:

  * Inserting into `ar_invoices` when order status flips to `shipped`/`delivered`
  * Or transforming existing invoice records to match columns above
* For **ACH/card** capture flows, record successful captures as `ar_payments` and allocate to target invoice
* Add a nightly job to email statements: pull `agingBuckets()` + customer contacts and send PDFs

That’s it. After you paste these files and run the migration, mount the router and the credit enforcement middleware on order creation. Then validate with the quick test plan above.

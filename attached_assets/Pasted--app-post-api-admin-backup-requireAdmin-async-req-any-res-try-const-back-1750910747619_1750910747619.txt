
  app.post('/api/admin/backup', requireAdmin, async (req: any, res) => {
    try {
      const backupResult = await storage.createBackup();
      res.json({
        success: true,
        message: 'Backup created successfully',
        backup: backupResult
      });
    } catch (error) {
      console.error('Error creating backup:', error);
      res.status(500).json({ message: 'Failed to create backup' });
    }
  });



  // Admin endpoint to view customer order history
  app.get('/api/admin/users/:userId/orders', requireAdmin, async (req: any, res) => {
    try {
      const { userId } = req.params;

      if (!userId) {
        return res.status(400).json({ message: 'User ID is required' });
      }

      const orders = await storage.getOrdersByUserId(userId);
      res.json(orders || []);
    } catch (error) {
      console.error('Error fetching customer order history:', error);
      res.status(500).json({ message: 'Failed to fetch customer order history' });
    }
  });

  // Duplicate price-history endpoint removed - using implementation at line 2477

  // Backup System Endpoints

  // Create new backup
  app.post('/api/admin/backup/create-new', requireAdmin, async (req: any, res) => {
    try {
      const backupResult = await storage.createBackup();
      res.json(backupResult);
    } catch (error) {
      console.error('Error creating backup:', error);
      res.status(500).json({ message: 'Failed to create backup' });
    }
  });

  // List all backups
  app.get('/api/admin/backup/list', requireAdmin, async (req: any, res) => {
    try {
      const backups = await storage.getBackupList();
      res.json({ backups });
    } catch (error) {
      console.error('Error listing backups:', error);
      res.status(500).json({ message: 'Failed to list backups' });
    }
  });

  // Download backup file
  app.get('/api/admin/backup/download/:filename', requireAdmin, async (req: any, res) => {
    try {
      const { filename } = req.params;
      const filePath = await storage.getBackupFilePath(filename);

      if (!filePath) {
        return res.status(404).json({ message: 'Backup file not found' });
      }

      res.download(filePath, filename);
    } catch (error) {
      console.error('Error downloading backup:', error);
      res.status(500).json({ message: 'Failed to download backup' });
    }
  });

  // Delete backup file
  app.delete('/api/admin/backup/:filename', requireAdmin, async (req: any, res) => {
    try {
      const { filename } = req.params;
      await storage.deleteBackup(filename);
      res.json({ message: 'Backup deleted successfully' });
    } catch (error) {
      console.error('Error deleting backup:', error);
      res.status(500).json({ message: 'Failed to delete backup' });
    }
  });

  // Restore from backup
  app.post('/api/admin/restore', requireAdmin, async (req: any, res) => {
    try {
      const { filename } = req.body;
      if (!filename) {
        return res.status(400).json({ message: 'Backup filename is required' });
      }

      const restoreResult = await storage.restoreFromBackup(filename);
      res.json(restoreResult);
    } catch (error) {
      console.error('Error restoring backup:', error);
      res.status(500).json({ message: 'Failed to restore backup' });
    }
  });



  // Product image upload endpoint
  app.post('/api/admin/products/:id/upload-image', requireEmployeeOrAdmin, upload.single('image'), async (req: any, res) => {
    try {
      const productId = parseInt(req.params.id);

      if (!req.file) {
        return res.status(400).json({ message: 'No image file provided' });
      }

      const imageUrl = `/uploads/${req.file.filename}`;
      console.log(`Uploading image for product ${productId}: ${imageUrl}`);

      const updatedProduct = await storage.updateProduct(productId, { imageUrl });

      if (!updatedProduct) {
        fs.unlink(req.file.path, (err) => {
          if (err) console.error('Error deleting uploaded file:', err);
        });
        return res.status(404).json({ message: 'Product not found' });
      }

      // Log image upload activity
      await storage.addActivityLog({
        userId: req.user.id,
        username: req.user.username,
        action: 'PRODUCT_IMAGE_UPLOADED',
        details: `Uploaded new image for product "${updatedProduct.name}" (ID: ${productId}) - File: ${req.file.filename}`,
        timestamp: new Date(),
        targetId: productId.toString(),
        targetType: 'product'
      });

      res.json({ 
        success: true, 
        imageUrl,
        product: updatedProduct,
        message: 'Image uploaded successfully'
      });
    } catch (error) {
      console.error('Error uploading product image:', error);

      if (req.file) {
        fs.unlink(req.file.path, (err) => {
          if (err) console.error('Error deleting uploaded file:', err);
        });
      }

      res.status(500).json({ message: 'Failed to upload image' });
    }
  });

  // Product image URL update endpoint
  app.put('/api/admin/products/:id/image', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const productId = parseInt(req.params.id);
      const { imageUrl } = req.body;

      if (!imageUrl) {
        return res.status(400).json({ message: 'Image URL is required' });
      }

      console.log(`Updating product ${productId} image URL to: ${imageUrl}`);

      const updatedProduct = await storage.updateProduct(productId, { imageUrl });

      if (!updatedProduct) {
        return res.status(404).json({ message: 'Product not found' });
      }

      // Log image URL update activity
      await storage.addActivityLog({
        userId: req.user.id,
        username: req.user.username,
        action: 'PRODUCT_IMAGE_URL_UPDATED',
        details: `Updated image URL for product "${updatedProduct.name}" (ID: ${productId}) - New URL: ${imageUrl}`,
        timestamp: new Date(),
        targetId: productId.toString(),
        targetType: 'product'
      });

      res.json({ 
        success: true, 
        product: updatedProduct,
        message: 'Image URL updated successfully'
      });
    } catch (error) {
      console.error('Error updating product image URL:', error);
      res.status(500).json({ message: 'Failed to update image URL' });
    }
  });

  // ============================================================================
  // PUSH NOTIFICATION DEVICE TOKEN MANAGEMENT ENDPOINTS
  // ============================================================================

  // Register device token for push notifications
  app.post('/api/push-notifications/register', requireAuth, async (req: any, res) => {
    try {
      const { token, platform, deviceInfo } = req.body;
      const userId = req.user.id;

      if (!token || !platform) {
        return res.status(400).json({ message: 'Token and platform are required' });
      }

      const deviceToken = await storage.registerDeviceToken(userId, token, platform, deviceInfo);
      res.json({ success: true, deviceToken });
    } catch (error) {
      console.error('Error registering device token:', error);
      res.status(500).json({ message: 'Failed to register device token' });
    }
  });

  // Remove device token
  app.delete('/api/push-notifications/tokens/:token', requireAuth, async (req: any, res) => {
    try {
      const { token } = req.params;
      const userId = req.user.id;

      await storage.removeDeviceToken(userId, token);
      res.json({ success: true });
    } catch (error) {
      console.error('Error removing device token:', error);
      res.status(500).json({ message: 'Failed to remove device token' });
    }
  });

  // Get user's device tokens
  app.get('/api/push-notifications/tokens', requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const tokens = await storage.getUserDeviceTokens(userId);
      res.json(tokens);
    } catch (error) {
      console.error('Error fetching device tokens:', error);
      res.status(500).json({ message: 'Failed to fetch device tokens' });
    }
  });

  // Get push notification settings
  app.get('/api/push-notifications/settings', requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const settings = await storage.getPushNotificationSettings(userId);
      res.json(settings || {
        orderUpdates: true,
        promotions: true,
        systemNotifications: true,
        lowStockAlerts: req.user.isAdmin || req.user.isEmployee
      });
    } catch (error) {
      console.error('Error fetching push notification settings:', error);
      res.status(500).json({ message: 'Failed to fetch push notification settings' });
    }
  });

  // Update push notification settings
  app.put('/api/push-notifications/settings', requireAuth, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const settings = req.body;

      const updatedSettings = await storage.updatePushNotificationSettings(userId, settings);
      res.json(updatedSettings);
    } catch (error) {
      console.error('Error updating push notification settings:', error);
      res.status(500).json({ message: 'Failed to update push notification settings' });
    }
  });

  // Admin endpoint to send test notification
  app.post('/api/push-notifications/test', requireAdmin, async (req: any, res) => {
    try {
      const { userId, title, message, type } = req.body;

      if (!userId || !title || !message) {
        return res.status(400).json({ message: 'UserId, title, and message are required' });
      }

      await pushNotificationService.sendToUser(userId, {
        title,
        body: message,
        icon: '/favicon.ico',
        data: {
          type: type || 'test',
          url: '/dashboard'
        }
      });

      res.json({ success: true, message: 'Test notification sent' });
    } catch (error) {
      console.error('Error sending test notification:', error);
      res.status(500).json({ message: 'Failed to send test notification' });
    }
  });

  // Admin endpoint to send bulk notifications
  app.post('/api/push-notifications/broadcast', requireAdmin, async (req: any, res) => {
    try {
      const { title, message, targetRole, data } = req.body;

      if (!title || !message) {
        return res.status(400).json({ message: 'Title and message are required' });
      }

      const payload = {
        title,
        body: message,
        icon: '/favicon.ico',
        data: data || { type: 'broadcast', url: '/dashboard' }
      };

      switch (targetRole) {
        case 'admin':
          await pushNotificationService.sendToAllAdmins(payload);
          break;
        case 'staff':
          await pushNotificationService.sendToAllStaff(payload);
          break;
        case 'customer':
          await pushNotificationService.sendToUsersByRole('customer', payload);
          break;
        default:
          // Send to all users
          const users = await storage.getAllUsers();
          const promises = users.map(user => pushNotificationService.sendToUser(user.id, payload));
          await Promise.allSettled(promises);
      }

      res.json({ success: true, message: 'Broadcast notification sent' });
    } catch (error) {
      console.error('Error sending broadcast notification:', error);
      res.status(500).json({ message: 'Failed to send broadcast notification' });
    }
  });

  // Missing endpoints to fix frontend-backend mismatches

  // Cart clear endpoint
  app.delete('/api/cart/clear', requireAuth, async (req: any, res) => {
    try {
      await storage.clearUserCart(req.user.id);
      res.json({ message: 'Cart cleared successfully' });
    } catch (error) {
      console.error('Error clearing cart:', error);
      res.status(500).json({ message: 'Failed to clear cart' });
    }
  });

  // Admin clear global cart endpoint
  app.delete('/api/admin/clear-global-cart', requireAdmin, async (req: any, res) => {
    try {
      await storage.clearAllCarts();
      res.json({ message: 'All carts cleared successfully' });
    } catch (error) {
      console.error('Error clearing all carts:', error);
      res.status(500).json({ message: 'Failed to clear all carts' });
    }
  });

  // Notification read status endpoints
  app.patch('/api/notifications/:notificationId/read', requireAuth, async (req: any, res) => {
    try {
      const { notificationId } = req.params;
      await storage.markNotificationAsRead(notificationId, req.user.id);
      res.json({ message: 'Notification marked as read' });
    } catch (error) {
      console.error('Error marking notification as read:', error);
      res.status(500).json({ message: 'Failed to mark notification as read' });
    }
  });

  app.delete('/api/notifications/:notificationId', requireAuth, async (req: any, res) => {
    try {
      const { notificationId } = req.params;
      await storage.deleteNotification(notificationId, req.user.id);
      res.json({ message: 'Notification deleted successfully' });
    } catch (error) {
      console.error('Error deleting notification:', error);
      res.status(500).json({ message: 'Failed to delete notification' });
    }
  });

  // Delivery address endpoints
  app.get('/api/delivery-addresses/:id', requireAuth, async (req: any, res) => {
    try {
      const { id } = req.params;
      const address = await storage.getDeliveryAddress(parseInt(id));
      if (!address) {
        return res.status(404).json({ message: 'Address not found' });
      }
      res.json(address);
    } catch (error) {
      console.error('Error fetching address:', error);
      res.status(500).json({ message: 'Failed to fetch address' });
    }
  });

  app.put('/api/delivery-addresses/:id', requireAuth, async (req: any, res) => {
    try {
      const { id } = req.params;
      const updatedAddress = await storage.updateDeliveryAddress(parseInt(id), req.body);
      res.json(updatedAddress);
    } catch (error) {
      console.error('Error updating address:', error);
      res.status(500).json({ message: 'Failed to update address' });
    }
  });

  app.delete('/api/delivery-addresses/:id', requireAuth, async (req: any, res) => {
    try {
      const { id } = req.params;
      await storage.deleteDeliveryAddress(parseInt(id));
      res.json({ message: 'Address deleted successfully' });
    } catch (error) {
      console.error('Error deleting address:', error);
      res.status(500).json({ message: 'Failed to delete address' });
    }
  });

  app.post('/api/delivery-addresses/:id/set-default', requireAuth, async (req: any, res) => {
    try {
      const { id } = req.params;
      await storage.setDefaultDeliveryAddress(parseInt(id), req.user.id);
      res.json({ message: 'Default address set successfully' });
    } catch (error) {
      console.error('Error setting default address:', error);
      res.status(500).json({ message: 'Failed to set default address' });
    }
  });

  // Order notes endpoints
  app.get('/api/orders/:orderId/notes', requireAuth, async (req: any, res) => {
    try {
      const { orderId } = req.params;
      const notes = await storage.getOrderNotes(parseInt(orderId));
      res.json(notes);
    } catch (error) {
      console.error('Error fetching order notes:', error);
      res.status(500).json({ message: 'Failed to fetch order notes' });
    }
  });

  app.post('/api/orders/:orderId/notes', requireAuth, async (req: any, res) => {
    try {
      const { orderId } = req.params;
      const { note, notifyCustomer } = req.body;

      const orderNote = await storage.addOrderNote(parseInt(orderId), req.body, req.user.id);

      // Check if this is a customer adding a note (not staff/admin)
      const isCustomerNote = !req.user.isAdmin && !req.user.isEmployee;

      if (isCustomerNote) {
        // Send push notification to staff when customer adds a note
        try {
          const customerName = req.user.username || req.user.firstName || 'Customer';
          await pushNotificationService.notifyCustomerNote(
            parseInt(orderId),
            customerName,
            note
          );
          console.log(`Push notification sent to staff for customer note on order #${orderId}`);
        } catch (notificationError) {
          console.error('Failed to send push notification for customer note:', notificationError);
          // Don't fail the note creation if notification fails
        }
      }

      res.json(orderNote);
    } catch (error) {
      console.error('Error adding order note:', error);
      res.status(500).json({ message: 'Failed to add order note' });
    }
  });

  app.delete('/api/orders/:orderId/notes/:noteId', requireAuth, async (req: any, res) => {
    try {
      const { noteId } = req.params;
      await storage.deleteOrderNote(parseInt(noteId));
      res.json({ message: 'Note deleted successfully' });
    } catch (error) {
      console.error('Error deleting order note:', error);
      res.status(500).json({ message: 'Failed to delete note' });
    }
  });

  // Order items endpoints
  app.post('/api/orders/:orderId/items', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const { orderId } = req.params;
      const item = await storage.addOrderItem(parseInt(orderId), req.body);
      res.json(item);
    } catch (error) {
      console.error('Error adding order item:', error);
      res.status(500).json({ message: 'Failed to add order item' });
    }
  });

  app.put('/api/orders/:orderId/items/:itemId', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const { itemId } = req.params;
      const updatedItem = await storage.updateOrderItem(parseInt(itemId), req.body);
      res.json(updatedItem);
    } catch (error) {
      console.error('Error updating order item:', error);
      res.status(500).json({ message: 'Failed to update order item' });
    }
  });

  // Order completion endpoint
  app.post('/api/orders/:id/complete', requireEmployeeOrAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      const completedOrder = await storage.completeOrder(parseInt(id), req.body);
      res.json(completedOrder);
    } catch (error) {
      console.error('Error completing order:', error);
      res.status(500).json({ message: 'Failed to complete order' });
    }
  });

  // Product search endpoint
  app.get('/api/products/search', async (req: any, res) => {
    try {
      const { q } = req.query;
      if (!q) {
        return res.status(400).json({ message: 'Search query is required' });
      }
      const products = await storage.searchProducts(q.toString());
      res.json(products);
    } catch (error) {
      console.error('Error searching products:', error);
      res.status(500).json({ message: 'Failed to search products' });
    }
  });

  // Addresses endpoint
  app.get('/api/addresses', requireAuth, async (req: any, res) => {
    try {
      const addresses = await storage.getUserDeliveryAddresses(req.user.id);
      res.json(addresses);
    } catch (error) {
      console.error('Error fetching addresses:', error);
      res.status(500).json({ message: 'Failed to fetch addresses' });
    }
  });

  // Recent orders endpoint
  app.get('/api/orders/recent', requireAuth, async (req: any, res) => {
    try {
      const limit = parseInt(req.query.limit?.toString() || '10');
      const orders = await storage.getRecentOrders(req.user.id, limit);
      res.json(orders);
    } catch (error) {
      console.error('Error fetching recent orders:', error);
      res.status(500).json({ message: 'Failed to fetch recent orders' });
    }
  });

  // 404 handler for API routes
  app.use('/api/*', (req, res) => {
    res.status(404).json({ message: 'API endpoint not found' });
  });

  // Import and register all route modules
  const authRoutes = await import('./routes/auth');
  const cartRoutes = await import('./routes/cart');
  const notificationRoutes = await import('./routes/notification');

  app.use("/api", authRoutes.default);
  app.use("/api", cartRoutes.default);
  app.use("/api", notificationRoutes.default);

  // Import invoice processor and purchase orders routes
  const invoiceProcessorRoutes = await import('./routes/invoice-processor');
  const purchaseOrderRoutes = await import('./routes/purchase-orders');

  app.use("/api", invoiceProcessorRoutes.default);
  app.use("/api", purchaseOrderRoutes.default);

  const httpServer = createServer(app);
  return httpServer;
}
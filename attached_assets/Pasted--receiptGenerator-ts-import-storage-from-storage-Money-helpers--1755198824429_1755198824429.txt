// receiptGenerator.ts
import { storage } from "../storage";

// ---------- Money helpers ----------
const toC = (n: number) => Math.round((n || 0) * 100); // dollars -> cents
const fromC = (c: number) => c / 100;
const USD = new Intl.NumberFormat("en-US", { style: "currency", currency: "USD" });
const fmt$ = (cents: number) => USD.format(fromC(cents));

// ---------- Types ----------
interface ReceiptItemInput {
  name: string;
  quantity: number;
  price: number;             // unit price (dollars)
  total: number;             // will be recomputed from cents for safety
  hasIlTobaccoTax?: boolean; // flag only if actual 45% IL OTP is applicable
  flatTaxAmount?: number;    // fallback per-unit amount (dollars) if needed
  flatTaxName?: string;
  basePrice?: number;
  unitPriceWithTax?: number;
  // (Optional) preferred flags used during enrichment:
  productName?: string;
  productId?: number;
  isTobaccoProduct?: boolean;
  taxPercentage?: number;
  flatTaxIds?: number[];     // recommended: use item.flatTaxId (singular) if business rule is only one
}

interface ReceiptData {
  orderId: number;
  orderNumber?: string;
  customerName: string;
  customerBusinessName?: string;
  customerEmail: string;
  customerAddress?: string;
  customerPhone?: string;
  orderDate: string;
  deliveryDate?: string;
  deliveryTimeSlot?: string;
  items: ReceiptItemInput[];
  subtotal: number;         // dollars (will be recomputed to ensure integrity)
  deliveryFee: number;      // dollars
  total: number;            // dollars (final)
  paymentMethod?: string;
  checkNumber?: string;
  paymentNotes?: string;
  paymentDate?: string;
  orderType: "delivery" | "pickup";
  pickupDate?: string;
  pickupTime?: string;
  customerLevel?: number;
  orderStatus?: string;
  customerNotes?: string;

  // Loyalty
  loyaltyPointsEarned?: number;   // 2 pts/$1 on non-tobacco items only
  loyaltyPointsRedeemed?: number; // points used
  loyaltyPointsValue?: number;    // dollars discount (will be converted to cents)
  totalLoyaltyPoints?: number;

  // Taxes
  hasIlTobaccoProducts?: boolean; // contains IL OTP items (45%) — display banner ONLY if this is true
  totalFlatTax?: number;          // dollars
  flatTaxBreakdown?: Array<{ name: string; amount: number; description?: string }>;

  // Credit
  creditAccountInfo?: {
    previousBalance: number;
    currentBalance: number;
    creditLimit: number;
    paymentMethod?: string;
  };
}

// ---------- Company constants ----------
const COMPANY = {
  name: "Gokul Wholesale Inc.",
  address: "1141 W Bryn Mawr Ave, Itasca, IL 60143",
  phone: "(630) 540-9910",
  email: "sales@gokulwholesaleinc.com",
  website: "www.shopgokul.com",
  tp: "TP#97239",
  feinLabel: "FEIN",
};

export class ReceiptGenerator {
  private static instance: ReceiptGenerator;
  static getInstance(): ReceiptGenerator {
    if (!ReceiptGenerator.instance) {
      ReceiptGenerator.instance = new ReceiptGenerator();
    }
    return ReceiptGenerator.instance;
  }

  // ---------- Credit balance (single, canonical) ----------
  private async calculatePreviousBalance(customerId: string, currentOrderId: number) {
    try {
      const customer = await storage.getUser(customerId);
      const creditLimit = customer?.creditLimit ?? 5000;

      const orders = await storage.getOrdersByUserId(customerId);
      const completedCreditOrders = orders.filter(
        (o: any) =>
          o.status === "completed" &&
          o.id !== currentOrderId &&
          (o.paymentMethod === "on_account" || o.paymentMethod === "credit")
      );

      const previousBalance = completedCreditOrders.reduce((s: number, o: any) => s + (o.total || 0), 0);
      const currentOrder = await storage.getOrderById(currentOrderId);
      const currentOrderTotal = currentOrder?.total || 0;
      const currentBalance = previousBalance + currentOrderTotal;

      return { previousBalance, currentBalance, creditLimit };
    } catch (err) {
      return { previousBalance: 0, currentBalance: 0, creditLimit: 5000 };
    }
  }

  // ---------- Public: generate receipt for order id ----------
  async generateReceiptOnly(orderId: number): Promise<{ success: boolean; message?: string; pdfBuffer?: Buffer }> {
    try {
      // Load order + items
      const order = await storage.getOrderWithItems(orderId);
      if (!order) return { success: false, message: "Order not found" };

      const customer = await storage.getUser(order.userId);
      if (!customer) return { success: false, message: "Customer not found" };

      // Enrich items with product meta (isTobaccoProduct, tax ids, etc.)
      const itemsWithProductInfo = await Promise.all(
        (order.items || []).map(async (item: any) => {
          const base: any = { ...item };
          let productData: any = null;
          if (item.productId) {
            try {
              productData = await storage.getProductById(item.productId);
            } catch {}
          }
          const productName = productData?.name || item.productName || item.name || `Product #${item.productId}`;
          return {
            ...item,
            productName,
            name: productName,
            isTobaccoProduct: !!productData?.isTobaccoProduct,
            taxPercentage: productData?.taxPercentage || 0,
            flatTaxIds: productData?.flatTaxIds || item.flatTaxIds || [],
            hasIlTobaccoTax: !!(productData?.isTobaccoProduct && productData?.taxPercentage === 45),
            // keep item.flatTaxAmount as *display-only* fallback; DB will be SoT for rate
          };
        })
      );

      // ---- Cents-safe totals ----
      const itemsSubtotalC = (order.items || []).reduce(
        (s: number, it: any) => s + toC(it.price || 0) * (it.quantity || 1),
        0
      );

      // Build flat tax breakdown from DB (source of truth)
      const flatTaxMap = new Map<string, { name: string; amountC: number; items: string[] }>();
      for (const it of itemsWithProductInfo) {
        const qty = it.quantity || 1;
        const ids = Array.isArray(it.flatTaxIds) ? it.flatTaxIds : [];
        for (const flatTaxId of ids) {
          const ft = await storage.getFlatTaxById(flatTaxId); // { id, name, amount } in dollars
          if (!ft) continue;
          const perUnitC = toC(ft.amount);
          const lineTaxC = perUnitC * qty;
          const key = `${ft.name}|${perUnitC}`;
          const entry = flatTaxMap.get(key) ?? { name: ft.name, amountC: 0, items: [] };
          entry.amountC += lineTaxC;
          entry.items.push(`${it.productName} (${qty} × ${fmt$(perUnitC)})`);
          flatTaxMap.set(key, entry);
        }
      }
      const flatTaxBreakdown = [...flatTaxMap.values()].map((x) => ({
        name: x.name,
        amount: fromC(x.amountC),
        description: x.items.join(", "),
      }));
      const totalFlatTaxC = [...flatTaxMap.values()].reduce((s, x) => s + x.amountC, 0);

      const deliveryFeeC = toC(order.deliveryFee || 0);
      const loyaltyDiscountC = toC(order.loyaltyPointsValue || 0);

      // Loyalty earn: 2 pts/$1 on non-tobacco items only (exclude taxes & delivery)
      const loyaltyEligibleC = itemsWithProductInfo.reduce((s: number, it: any) => {
        if (it.isTobaccoProduct) return s;
        return s + toC(it.price || 0) * (it.quantity || 1);
      }, 0);
      const loyaltyPointsEarned = Math.floor(fromC(loyaltyEligibleC) * 2);

      // Final total (prefer stored snapshot for finalized orders; otherwise recompute)
      const recomputedFinalC = itemsSubtotalC + totalFlatTaxC + deliveryFeeC - loyaltyDiscountC;
      const isFinalized =
        typeof order.status === "string" &&
        ["completed", "delivered", "paid"].includes(order.status.toLowerCase());
      const finalTotalC = isFinalized ? toC(order.total || 0) || recomputedFinalC : recomputedFinalC;

      // Invariants (soft check)
      const subtotalBeforeDeliveryC = itemsSubtotalC + totalFlatTaxC;
      const invariantOk = finalTotalC === subtotalBeforeDeliveryC + deliveryFeeC - loyaltyDiscountC;

      // Receipt data snapshot
      const receiptData: ReceiptData = {
        orderId: order.id,
        orderNumber: String(order.id),
        customerName:
          customer.company ||
          `${customer.firstName || ""} ${customer.lastName || ""}`.trim() ||
          customer.username ||
          "Valued Customer",
        customerBusinessName: customer.company,
        customerEmail: customer.email || "",
        customerAddress: customer.address || "",
        customerPhone: customer.cellPhone || customer.phone,
        orderDate: new Date(order.createdAt || new Date()).toLocaleDateString("en-US"),
        orderType: order.orderType,
        items: itemsWithProductInfo.map((it: any) => ({
          name: it.productName || "Unknown Item",
          quantity: it.quantity || 1,
          price: it.price || 0,
          total: (it.price || 0) * (it.quantity || 1), // display only; we show cents-safe numbers in PDF
          hasIlTobaccoTax: !!it.hasIlTobaccoTax,
          flatTaxAmount: it.flatTaxAmount || 0,
          flatTaxName: it.flatTaxName || "",
        })),
        subtotal: fromC(itemsSubtotalC),
        deliveryFee: fromC(deliveryFeeC),
        total: fromC(finalTotalC),
        paymentMethod: order.paymentMethod || "cash",
        orderStatus: order.status || "completed",
        customerNotes: order.notes || "",
        loyaltyPointsRedeemed: order.loyaltyPointsRedeemed || 0,
        loyaltyPointsValue: fromC(loyaltyDiscountC),
        totalFlatTax: fromC(totalFlatTaxC),
        flatTaxBreakdown,
        // Banner should reflect actual OTP, not county flat taxes:
        hasIlTobaccoProducts: itemsWithProductInfo.some((it: any) => !!it.hasIlTobaccoTax),
        loyaltyPointsEarned,
      };

      // Credit info
      if (order.paymentMethod === "on_account" || order.paymentMethod === "credit") {
        const creditInfo = await this.calculatePreviousBalance(customer.id, order.id);
        receiptData.creditAccountInfo = {
          previousBalance: creditInfo.previousBalance,
          currentBalance: creditInfo.currentBalance,
          creditLimit: creditInfo.creditLimit,
          paymentMethod: order.paymentMethod,
        };
      }

      // Generate PDF
      const pdfBuffer = await this.generateReceiptPDF(receiptData, { invariantOk, subtotalBeforeDeliveryC, finalTotalC, deliveryFeeC, loyaltyDiscountC });
      return { success: true, pdfBuffer };
    } catch (error: any) {
      return { success: false, message: `Error generating receipt: ${error?.message || "Unknown error"}` };
    }
  }

  // ---------- PDF generator (switchable designs) ----------
  private async generateReceiptPDF(
    receiptData: ReceiptData,
    diag?: { invariantOk: boolean; subtotalBeforeDeliveryC: number; finalTotalC: number; deliveryFeeC: number; loyaltyDiscountC: number }
  ): Promise<Buffer> {
    const { jsPDF } = await import("jspdf");
    const fs = await import("fs");
    const path = await import("path");

    const USE_PREMIUM_DESIGN = true;
    const doc = new jsPDF();
    const pageWidth = doc.internal.pageSize.width;
    const pageHeight = doc.internal.pageSize.height;

    if (USE_PREMIUM_DESIGN) {
      return await this.generatePremiumInvoice(doc, receiptData, fs, path, pageWidth, pageHeight);
    }

    // (Optional) Original design path — omitted for brevity
    return await this.generatePremiumInvoice(doc, receiptData, fs, path, pageWidth, pageHeight);
  }

  // ---------- Pagination helper ----------
  private ensureRoom(doc: any, y: number, needed: number, pageHeight: number, newPageTop = 20) {
    if (y + needed > pageHeight - 30) {
      doc.addPage();
      return newPageTop;
    }
    return y;
  }

  // ---------- Premium PDF ----------
  private async generatePremiumInvoice(
    doc: any,
    receiptData: ReceiptData,
    fs: any,
    path: any,
    pageWidth: number,
    pageHeight: number
  ): Promise<Buffer> {
    // Brand colors
    const brandBlue = [41, 128, 185] as const;
    const accentBlue = [52, 152, 219] as const;
    const darkGray = [44, 62, 80] as const;
    const lightGray = [236, 240, 241] as const;
    const successGreen = [39, 174, 96] as const;
    const alertOrange = [230, 126, 34] as const;
    const textDark = [33, 37, 41] as const;

    // Header
    doc.setFillColor(...brandBlue);
    doc.rect(0, 0, pageWidth, 45, "F");
    doc.setFillColor(...accentBlue);
    doc.rect(0, 0, pageWidth, 35, "F");

    try {
      const logoPath = path.join(process.cwd(), "public", "gokul-logo.png");
      if (fs.existsSync(logoPath)) {
        const logoData = fs.readFileSync(logoPath);
        const logoBase64 = `data:image/png;base64,${logoData.toString("base64")}`;
        doc.setFillColor(255, 255, 255);
        doc.circle(30, 22, 15, "F");
        doc.addImage(logoBase64, "PNG", 18, 10, 24, 24);
      }
    } catch {}

    doc.setTextColor(255, 255, 255);
    doc.setFontSize(20);
    doc.setFont("helvetica", "bold");
    doc.text("GOKUL WHOLESALE", 50, 18);
    doc.setFontSize(10);
    doc.setFont("helvetica", "italic");
    doc.text("Premium B2B Solutions • Wholesale Excellence", 50, 25);
    doc.setFontSize(9);
    doc.setFont("helvetica", "normal");
    doc.text(COMPANY.address, 50, 32);
    doc.text(`Phone: ${COMPANY.phone} • ${COMPANY.website}`, 50, 38);

    doc.setTextColor(255, 255, 255);
    doc.setFontSize(16);
    doc.setFont("helvetica", "bold");
    doc.text("INVOICE", pageWidth - 20, 18, { align: "right" });
    doc.setFontSize(10);
    doc.setFont("helvetica", "normal");
    doc.text(`Order #${receiptData.orderNumber}`, pageWidth - 20, 26, { align: "right" });
    doc.text(`${COMPANY.tp}`, pageWidth - 20, 33, { align: "right" });

    // Customer card
    const customerY = 55;
    doc.setTextColor(...textDark);
    doc.setFillColor(...lightGray);
    doc.rect(15, customerY, pageWidth - 30, 35, "F");
    doc.setDrawColor(...brandBlue);
    doc.setLineWidth(0.5);
    doc.rect(15, customerY, pageWidth - 30, 35);

    doc.setFontSize(12);
    doc.setFont("helvetica", "bold");
    doc.setTextColor(...darkGray);
    doc.text("BILL TO:", 20, customerY + 8);

    doc.setFontSize(11);
    doc.setFont("helvetica", "bold");
    doc.text(receiptData.customerBusinessName || receiptData.customerName, 20, customerY + 18);

    doc.setFontSize(9);
    doc.setFont("helvetica", "normal");
    if (receiptData.customerAddress) doc.text(receiptData.customerAddress, 20, customerY + 26);
    if (receiptData.customerPhone) doc.text(`Phone: ${receiptData.customerPhone}`, 20, customerY + 32);

    doc.setFontSize(10);
    doc.setFont("helvetica", "bold");
    doc.text("ORDER DETAILS:", pageWidth - 85, customerY + 8);
    doc.setFont("helvetica", "normal");
    doc.text(`Date: ${receiptData.orderDate}`, pageWidth - 85, customerY + 16);
    doc.text(`Type: ${receiptData.orderType.toUpperCase()}`, pageWidth - 85, customerY + 23);
    doc.text(`Status: ${(receiptData.orderStatus || "PENDING").toUpperCase()}`, pageWidth - 85, customerY + 30);

    // Table header
    let y = customerY + 50;
    doc.setFillColor(...brandBlue);
    doc.rect(15, y, pageWidth - 30, 12, "F");
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(10);
    doc.setFont("helvetica", "bold");
    doc.text("DESCRIPTION", 20, y + 8);
    doc.text("QTY", pageWidth - 80, y + 8, { align: "center" });
    doc.text("PRICE", pageWidth - 55, y + 8, { align: "center" });
    doc.text("TOTAL", pageWidth - 25, y + 8, { align: "right" });
    y += 12;

    // Rows
    doc.setTextColor(...textDark);
    receiptData.items.forEach((it, idx) => {
      const rowH = 15;
      y = this.ensureRoom(doc, y, rowH, pageHeight);
      if (idx % 2 === 0) {
        doc.setFillColor(248, 249, 250);
        doc.rect(15, y, pageWidth - 30, rowH, "F");
      }
      const qty = it.quantity || 1;
      const unitC = toC(it.price || 0);
      const lineC = unitC * qty;

      doc.setFontSize(10);
      doc.setFont("helvetica", "normal");
      const name = it.name.length > 45 ? it.name.slice(0, 42) + "..." : it.name;
      doc.text(name, 20, y + 8);
      doc.text(String(qty), pageWidth - 80, y + 8, { align: "center" });
      doc.text(fmt$(unitC), pageWidth - 55, y + 8, { align: "center" });
      doc.text(fmt$(lineC), pageWidth - 25, y + 8, { align: "right" });

      y += rowH;
    });

    // Summary card
    const summaryX = pageWidth - 90;
    const summaryW = 85;
    y += 10;
    y = this.ensureRoom(doc, y, 60, pageHeight);
    doc.setFillColor(...lightGray);
    doc.rect(summaryX - 10, y, summaryW, 60, "F");
    doc.setDrawColor(...brandBlue);
    doc.rect(summaryX - 10, y, summaryW, 60);

    let sy = y + 10;
    doc.setFontSize(10);
    doc.setFont("helvetica", "normal");

    const subtotalC = toC(receiptData.subtotal);
    doc.text("Subtotal:", summaryX, sy);
    doc.text(fmt$(subtotalC), pageWidth - 25, sy, { align: "right" });
    sy += 8;

    // Flat taxes (orange)
    if (receiptData.flatTaxBreakdown?.length) {
      receiptData.flatTaxBreakdown.forEach((ft) => {
        doc.setTextColor(...alertOrange);
        doc.text(`${ft.name}:`, summaryX, sy);
        doc.text(fmt$(toC(ft.amount)), pageWidth - 25, sy, { align: "right" });
        sy += 7;
      });
      doc.setTextColor(...textDark);
    }

    // Delivery
    const deliveryC = toC(receiptData.deliveryFee || 0);
    if (deliveryC > 0) {
      doc.text("Delivery Fee:", summaryX, sy);
      doc.text(fmt$(deliveryC), pageWidth - 25, sy, { align: "right" });
      sy += 8;
    }

    // Loyalty redeemed (if any)
    const redeemC = toC(receiptData.loyaltyPointsValue || 0);
    if (redeemC > 0) {
      doc.text("Loyalty Redeemed:", summaryX, sy);
      doc.text(`-${fmt$(redeemC)}`, pageWidth - 25, sy, { align: "right" });
      sy += 8;
    }

    // Total
    doc.setDrawColor(...brandBlue);
    doc.setLineWidth(1);
    doc.line(summaryX, sy, pageWidth - 25, sy);
    sy += 5;
    doc.setFontSize(12);
    doc.setFont("helvetica", "bold");
    doc.setTextColor(...brandBlue);
    const finalC = toC(receiptData.total || 0);
    doc.text("TOTAL:", summaryX, sy);
    doc.text(fmt$(finalC), pageWidth - 25, sy, { align: "right" });
    doc.setTextColor(...textDark);

    // Loyalty earned banner
    if (receiptData.loyaltyPointsEarned && receiptData.loyaltyPointsEarned > 0) {
      const ly = sy + 18;
      doc.setFillColor(...successGreen);
      doc.rect(15, ly, pageWidth - 30, 15, "F");
      doc.setTextColor(255, 255, 255);
      doc.setFontSize(10);
      doc.setFont("helvetica", "bold");
      doc.text(`LOYALTY POINTS EARNED: ${receiptData.loyaltyPointsEarned} POINTS`, 20, ly + 10);
      doc.setTextColor(...textDark);
    }

    // Footer
    const footerY = pageHeight - 30;
    doc.setFillColor(...brandBlue);
    doc.rect(0, footerY, pageWidth, 30, "F");
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(9);
    doc.setFont("helvetica", "normal");
    doc.text("Thank you for your business!", pageWidth / 2, footerY + 10, { align: "center" });
    doc.text(`Visit us at ${COMPANY.website} | Call ${COMPANY.phone}`, pageWidth / 2, footerY + 18, { align: "center" });

    // IL OTP compliance box (ONLY if true IL OTP applied)
    if (receiptData.hasIlTobaccoProducts) {
      const tbY = footerY - 20;
      doc.setDrawColor(...alertOrange);
      doc.setLineWidth(2);
      doc.rect(15, tbY, pageWidth - 30, 12);
      doc.setTextColor(...alertOrange);
      doc.setFontSize(10);
      doc.setFont("helvetica", "bold");
      doc.text("✓ 45% IL TOBACCO TAX PAID", pageWidth / 2, tbY + 7, { align: "center" });
      doc.setTextColor(...textDark);
    }

    // Return a real Buffer
    return Buffer.from(doc.output("arraybuffer"));
  }
}

export const receiptGenerator = ReceiptGenerator.getInstance();

// Combined IL tobacco/vapor tax calculations
// - 45% for all products on/after 2025-07-01
// - Legacy (pre-change) handling: OTP 36%, ECIG 15%
// - Always combines IL-OTP + IL-ECIG into one report output
// - Computes tax per line using the appropriate date-specific rate and sums to avoid rounding issues across rate periods

export type Program = "IL-OTP" | "IL-ECIG" | string;

export interface Transaction {
  date: string; // ISO or M/D/YYYY
  program: Program; // "IL-OTP" | "IL-ECIG"
  category: string; // e.g., "Large Cigar", "Alternative Nicotine Product", "Vapor Product", "Pipe Tobacco", "Roll your own"
  unitPrice: number; // wholesale unit price
  quantity: number; // integer
  // Optional identifiers you might have in your DB (ignored by math)
  invoiceNumber?: string | number;
  customerId?: string | number;
  sku?: string;
}

export interface Period {
  start: Date;
  end: Date;
}

export interface CategoryTotals {
  base: number; // sum of (unitPrice * quantity)
  tax: number;  // sum of per-line (base * applicableRate(lineDate))
}

export interface ReportTotals {
  period: Period;
  lines: number;
  units: number;
  baseTotal: number;
  taxTotal: number;
  effectiveRate: number; // taxTotal / baseTotal (weighted average)
  byCategory: Record<string, CategoryTotals>;
}

const EFFECTIVE_DATE = new Date("2025-07-01");
const NEW_RATE_ALL = 0.45; // from 2025-07-01 forward
const LEGACY_OTP_RATE = 0.36; // before 2025-07-01
const LEGACY_ECIG_RATE = 0.15; // before 2025-07-01

function parseDateLoose(input: string): Date {
  // Accept ISO or M/D/YYYY
  const tryIso = new Date(input);
  if (!Number.isNaN(tryIso.getTime())) return tryIso;
  const parts = input.split("/");
  if (parts.length === 3) {
    const m = parseInt(parts[0], 10);
    const d = parseInt(parts[1], 10);
    const y = parseInt(parts[2], 10);
    const dt = new Date(Date.UTC(y, m - 1, d));
    if (!Number.isNaN(dt.getTime())) return dt;
  }
  throw new Error(`Invalid date: ${input}`);
}

export function monthRange(year: number, month: number): Period {
  const start = new Date(Date.UTC(year, month - 1, 1, 0, 0, 0));
  const end = new Date(Date.UTC(year, month, 0, 23, 59, 59, 999)); // last day of month
  return { start, end };
}

export function prevMonthPeriod(ref: Date = new Date()): Period {
  const y = ref.getUTCFullYear();
  const m = ref.getUTCMonth() + 1;
  const prev = m === 1 ? { y: y - 1, m: 12 } : { y, m: m - 1 };
  return monthRange(prev.y, prev.m);
}

function inRange(d: Date, period: Period): boolean {
  return d >= period.start && d <= period.end;
}

function rateFor(program: Program, d: Date): number {
  if (d >= EFFECTIVE_DATE) return NEW_RATE_ALL;
  const up = String(program || "").toUpperCase();
  if (up === "IL-OTP") return LEGACY_OTP_RATE;
  if (up === "IL-ECIG") return LEGACY_ECIG_RATE;
  // Anything else (shouldn't happen) -> 0% before effective date
  return 0;
}

export function computeCombinedReport(transactions: Transaction[], period: Period): ReportTotals {
  let lines = 0;
  let units = 0;
  let baseTotal = 0;
  let taxTotal = 0;
  const byCategory: Record<string, CategoryTotals> = {};

  for (const t of transactions) {
    const d = parseDateLoose(t.date);
    if (!inRange(d, period)) continue;

    const qty = Number.isFinite(t.quantity) ? Math.trunc(t.quantity) : 0;
    const price = Number(t.unitPrice);
    if (!qty || !Number.isFinite(price)) continue;

    const base = price * qty;
    const rate = rateFor(t.program, d);
    const tax = round2(base * rate);

    lines += 1;
    units += qty;
    baseTotal += base;
    taxTotal += tax;

    const cat = t.category || "Uncategorized";
    if (!byCategory[cat]) byCategory[cat] = { base: 0, tax: 0 };
    byCategory[cat].base += base;
    byCategory[cat].tax += tax;
  }

  // Round category totals and grand totals to 2 decimals
  for (const cat of Object.keys(byCategory)) {
    byCategory[cat].base = round2(byCategory[cat].base);
    byCategory[cat].tax = round2(byCategory[cat].tax);
  }

  baseTotal = round2(baseTotal);
  taxTotal = round2(taxTotal);

  const effectiveRate = baseTotal > 0 ? taxTotal / baseTotal : 0;

  return {
    period,
    lines,
    units,
    baseTotal,
    taxTotal,
    effectiveRate,
    byCategory,
  };
}

export function formatCsv(report: ReportTotals): string {
  const header = [
    "period_start",
    "period_end",
    "lines",
    "units",
    "category",
    "wholesale_base",
    "tax",
  ].join(",");

  const rows: string[] = [header];
  const { period, lines, units } = report;

  const cats = Object.keys(report.byCategory).sort();
  for (const cat of cats) {
    const c = report.byCategory[cat];
    rows.push([
      isoDate(report.period.start),
      isoDate(report.period.end),
      String(lines),
      String(units),
      csvEscape(cat),
      toMoney(c.base),
      toMoney(c.tax),
    ].join(","));
  }
  // TOTAL row
  rows.push([
    isoDate(period.start),
    isoDate(period.end),
    String(lines),
    String(units),
    "TOTAL",
    toMoney(report.baseTotal),
    toMoney(report.taxTotal),
  ].join(","));

  return rows.join("\n");
}

function isoDate(d: Date): string {
  return new Date(d).toISOString().slice(0, 10);
}

function toMoney(n: number): string {
  return round2(n).toFixed(2);
}

function round2(n: number): number {
  return Math.round((n + Number.EPSILON) * 100) / 100;
}

function csvEscape(s: string): string {
  if (s.includes(",") || s.includes('"') || s.includes("\n")) {
    return `"${s.replace(/"/g, '""')}"`;
  }
  return s;
}
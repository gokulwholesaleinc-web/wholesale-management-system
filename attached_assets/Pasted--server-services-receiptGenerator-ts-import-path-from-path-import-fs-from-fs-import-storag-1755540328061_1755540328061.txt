// server/services/receiptGenerator.ts
import path from "path";
import fs from "fs";
import { storage } from "../storage"; // your existing storage interface
import { EmailService } from "./emailService"; // optional (used below)

/** ----------- lazy-load jsPDF + autotable for Node ----------- */
async function loadJsPDF() {
  const { jsPDF } = await import("jspdf");
  // side-effect import that adds autoTable(doc, ...)
  await import("jspdf-autotable");
  return jsPDF;
}

/** ----------- shared types (minimal) ----------- */
type FlatTaxLine = { name: string; amount: number; description?: string };

interface OrderItem {
  id: number;
  productId: number;
  quantity: number;
  price: number;
  productName?: string;
  product?: { id: number; name: string; sku?: string; isTobaccoProduct?: boolean };
  isTobaccoProduct?: boolean;
  flatTaxAmount?: number;
  totalTaxAmount?: number;
  flatTaxName?: string;
}

interface CalcLine { kind: string; label: string; amount: number; }
interface CalculationBreakdown {
  itemsSubtotal?: number;
  flatTaxTotal?: number;
  subtotalBeforeDelivery?: number;
  nonTobaccoSubtotal?: number;
  loyaltyPointsEarned?: number;
  loyaltyRedeemValue?: number;
  deliveryFee?: number;
  lines?: CalcLine[];
}

interface Order {
  id: number;
  userId: string;
  orderType: "delivery" | "pickup" | string;
  createdAt: string | null;
  total: number;
  items: OrderItem[];

  // optional fields commonly present in your API:
  deliveryFee?: number | null;
  notes?: string;
  status?: string;

  user?: {
    id: string;
    firstName?: string | null;
    lastName?: string | null;
    company?: string | null;
    businessName?: string | null;
    username: string;
    email?: string;
    phone?: string;
  };

  // server-provided breakdowns (if any)
  flatTaxBreakdown?: FlatTaxLine[];
  calculationBreakdown?: CalculationBreakdown;

  // loyalty / redemption
  loyaltyPointsRedeemed?: number;
  loyaltyPointsValue?: number;
  loyaltyPointsEarned?: number;

  // credit
  previousBalance?: number;
  creditAccountInfo?: { previousBalance?: number };
}

const COMPANY = {
  name: "Gokul Wholesale Inc.",
  address: "1141 W Bryn Mawr Ave, Itasca, IL 60143",
  phone: "(630) 540-9910",
  email: "sales@gokulwholesaleinc.com",
  website: "www.shopgokul.com",
  tp: "TP# 97239",
};

const fmt$ = (n: number) => `$${(Number(n) || 0).toFixed(2)}`;

/** ----------- credit helpers (ALWAYS show previous balance) ----------- */
async function getPreviousBalance(userId: string, currentOrderId: number) {
  try {
    const orders = await storage.getOrdersByUserId(userId);
    const prev = orders
      .filter(
        (o: any) =>
          o.id !== currentOrderId &&
          ["completed", "delivered", "paid"].includes(String(o.status).toLowerCase()) &&
          (o.paymentMethod === "on_account" || o.paymentMethod === "credit")
      )
      .reduce((sum: number, o: any) => sum + (o.total || 0), 0);
    return prev; // number
  } catch {
    return 0;
  }
}

/** ----------- build flat tax lines with graceful fallbacks ----------- */
function buildFlatTaxLines(order: Order): FlatTaxLine[] {
  if (Array.isArray(order.flatTaxBreakdown) && order.flatTaxBreakdown.length) {
    return order.flatTaxBreakdown.map((l) => ({ name: l.name, amount: Number(l.amount || 0) }));
  }
  if (order.calculationBreakdown?.lines?.length) {
    return order.calculationBreakdown.lines
      .filter((l) => l.kind === "flatTax")
      .map((l) => ({ name: l.label, amount: Number(l.amount || 0) }));
  }
  // group from items
  const grouped: Record<string, number> = {};
  for (const it of order.items) {
    const amt = Number(it.totalTaxAmount ?? it.flatTaxAmount ?? 0);
    if (!amt) continue;
    const name = it.flatTaxName || "Flat Taxes";
    grouped[name] = (grouped[name] || 0) + amt;
  }
  return Object.entries(grouped).map(([name, amount]) => ({ name, amount }));
}

/** ----------- loyalty earned (2 pts per $1 of non-tobacco) ----------- */
function computeLoyaltyEarned(order: Order) {
  if (typeof order.loyaltyPointsEarned === "number") return order.loyaltyPointsEarned;
  const eligible =
    order.calculationBreakdown?.nonTobaccoSubtotal ??
    order.items.reduce((s, it) => {
      const isTobacco = Boolean(it.isTobaccoProduct || it.product?.isTobaccoProduct);
      return isTobacco ? s : s + (it.price || 0) * (it.quantity || 0);
    }, 0);
  return Math.round((eligible || 0) * 2);
}

/** ----------- server: build Buffer PDF by order id ----------- */
export async function generateOrderPDFBuffer(orderId: number): Promise<Buffer> {
  // 1) load order with items & user
  const order: Order | null = await storage.getOrderWithItems(orderId);
  if (!order) throw new Error("Order not found");

  // ensure product meta if your storage can fetch product details
  for (const it of order.items) {
    if (!it.product && it.productId) {
      try {
        const p = await storage.getProductById(it.productId);
        it.product = { id: p.id, name: p.name, sku: p.sku, isTobaccoProduct: p.isTobaccoProduct };
        it.productName = p.name;
        if (typeof it.isTobaccoProduct === "undefined") it.isTobaccoProduct = p.isTobaccoProduct;
      } catch {}
    }
  }

  // 2) compute display numbers
  const itemsSubtotal = order.items.reduce(
    (s, it) => s + (it.price || 0) * (it.quantity || 0),
    0
  );
  const flatTaxLines = buildFlatTaxLines(order);
  const flatTaxTotal = flatTaxLines.reduce((s, l) => s + l.amount, 0);
  const deliveryFee = Number(order.deliveryFee || 0);
  const loyaltyRedeemValue = Number(order.loyaltyPointsValue || 0);

  const loyaltyEarned = computeLoyaltyEarned(order);

  const thisOrderDisplayTotal = itemsSubtotal + flatTaxTotal + deliveryFee - loyaltyRedeemValue;
  const thisOrderServerTotal = Number(order.total || thisOrderDisplayTotal);

  const prevBalanceFromOrder =
    (order as any).previousBalance ??
    order.creditAccountInfo?.previousBalance ??
    undefined;
  const previousBalance =
    typeof prevBalanceFromOrder === "number"
      ? prevBalanceFromOrder
      : await getPreviousBalance(order.userId, order.id);

  const amountDue = previousBalance + thisOrderServerTotal;

  // 3) render PDF
  const jsPDF = await loadJsPDF();
  const doc = new jsPDF();

  // header (logo + company)
  try {
    const logoPath = path.join(process.cwd(), "public", "IMG_0846.png"); // transparent PNG
    if (fs.existsSync(logoPath)) {
      const base64 = fs.readFileSync(logoPath).toString("base64");
      doc.addImage(`data:image/png;base64,${base64}`, "PNG", 20, 10, 25, 25);
    }
  } catch {}

  doc.setFont("helvetica", "bold").setFontSize(18);
  doc.text(COMPANY.name, 50, 20);

  doc.setFont("helvetica", "normal").setFontSize(10);
  doc.text(COMPANY.address, 50, 28);
  doc.text(`${COMPANY.phone} | ${COMPANY.email}`, 50, 34);
  doc.text(COMPANY.tp, 50, 40);

  doc.setFont("helvetica", "bold").setFontSize(12);
  doc.text(`Order #${order.id}`, 190, 20, { align: "right" });

  doc.setFont("helvetica", "normal").setFontSize(10);
  doc.text(`Date: ${order.createdAt ? new Date(order.createdAt).toLocaleDateString() : "N/A"}`, 190, 28, { align: "right" });

  // divider
  doc.setLineWidth(0.5);
  doc.line(15, 45, 195, 45);

  // customer panel
  const displayCustomerName =
    order.user?.company ||
    order.user?.businessName ||
    (order.user?.firstName && order.user?.lastName
      ? `${order.user.firstName} ${order.user.lastName}`
      : "") ||
    order.user?.username ||
    "Customer";

  let y = 54;
  doc.setFillColor(240, 240, 240);
  doc.rect(15, y, 180, 22, "F");
  doc.setFont("helvetica", "bold").setFontSize(11).setTextColor(33, 37, 41);
  doc.text("Customer Information", 20, y + 7);
  doc.setFont("helvetica", "normal").setFontSize(10).setTextColor(0, 0, 0);
  doc.text(displayCustomerName, 20, y + 15);
  if (order.user?.email) doc.text(`Email: ${order.user.email}`, 120, y + 11);
  if (order.user?.phone) doc.text(`Phone: ${order.user.phone}`, 120, y + 17);
  y += 30;

  // order type line
  const orderType = order.orderType === "delivery" ? "DELIVERY" : "PICKUP";
  doc.text(`Order Type: ${orderType}`, 20, y);
  y += 6;

  // items table
  const rows = order.items.map((it) => [
    it.product?.name || it.productName || "Product",
    it.product?.sku || "N/A",
    String(it.quantity),
    fmt$(it.price),
    fmt$((it.quantity || 0) * (it.price || 0)),
  ]);

  (doc as any).autoTable({
    startY: y + 4,
    head: [["Item Description", "SKU", "Qty", "Unit Price", "Total"]],
    body: rows,
    theme: "grid",
    headStyles: { fillColor: [38, 60, 82], textColor: 255, fontStyle: "bold" },
    styles: { fontSize: 9, cellPadding: 3 },
    columnStyles: {
      0: { cellWidth: 78 },
      1: { cellWidth: 32 },
      2: { cellWidth: 15, halign: "center" },
      3: { cellWidth: 25, halign: "right" },
      4: { cellWidth: 25, halign: "right" },
    },
  });

  let sy = (doc as any).lastAutoTable.finalY + 10;
  const sx = 120;

  // breakdown block (right aligned)
  doc.setFont("helvetica", "normal").setFontSize(11);
  doc.text("Items Subtotal:", sx, sy);
  doc.text(fmt$(itemsSubtotal), 195, sy, { align: "right" });
  sy += 7;

  for (const line of flatTaxLines) {
    doc.text(`${line.name}:`, sx, sy);
    doc.text(fmt$(line.amount), 195, sy, { align: "right" });
    sy += 7;
  }

  if (flatTaxLines.length) {
    doc.setFont("helvetica", "bold");
    doc.text("Subtotal (Items + Taxes):", sx, sy);
    doc.text(fmt$(itemsSubtotal + flatTaxTotal), 195, sy, { align: "right" });
    sy += 7;
    doc.setFont("helvetica", "normal");
  }

  if (deliveryFee > 0) {
    doc.text("Delivery Fee:", sx, sy);
    doc.text(fmt$(deliveryFee), 195, sy, { align: "right" });
    sy += 7;
  }

  if (order.loyaltyPointsRedeemed != null) {
    doc.text(`Loyalty Redeemed: ${order.loyaltyPointsRedeemed} pts`, sx, sy);
    doc.text(`-${fmt$(loyaltyRedeemValue)}`, 195, sy, { align: "right" });
    sy += 7;
  }

  // Previous balance (ALWAYS)
  doc.text("Previous Balance:", sx, sy);
  doc.text(fmt$(previousBalance), 195, sy, { align: "right" });
  sy += 4;

  // divider
  doc.setLineWidth(0.5);
  doc.line(sx, sy, 195, sy);
  sy += 6;

  doc.setFont("helvetica", "bold");
  doc.text("Total (This Order):", sx, sy);
  doc.text(fmt$(thisOrderServerTotal), 195, sy, { align: "right" });
  sy += 7;

  doc.text("Amount Due (Prev + This):", sx, sy);
  doc.text(fmt$(amountDue), 195, sy, { align: "right" });
  sy += 12;

  // loyalty earned banner
  if (loyaltyEarned >= 0) {
    doc.setFillColor(240, 248, 240);
    doc.rect(15, sy - 6, 180, 10, "F");
    doc.setTextColor(39, 174, 96);
    doc.setFont("helvetica", "bold").setFontSize(10);
    doc.text(`Loyalty Points Earned: ${loyaltyEarned} points`, 20, sy + 1);
    doc.setTextColor(0, 0, 0);
    sy += 14;
  }

  // tobacco notice (always show)
  const pageH = doc.internal.pageSize.height;
  const boxY = pageH - 28;
  doc.setDrawColor(230, 126, 34).setLineWidth(0.6);
  doc.rect(15, boxY, 80, 10);
  doc.setFont("helvetica", "bold").setFontSize(9).setTextColor(230, 126, 34);
  doc.text("45% IL TOBACCO TAX PAID", 55, boxY + 6, { align: "center" });
  doc.setTextColor(0, 0, 0);

  // footer
  doc.setFont("helvetica", "normal").setFontSize(9);
  doc.text("Thank you for your business!", 105, pageH - 14, { align: "center" });
  doc.text(COMPANY.website, 105, pageH - 8, { align: "center" });

  // return Node Buffer
  const arr = doc.output("arraybuffer") as ArrayBuffer;
  return Buffer.from(arr);
}

/** ----------- Express route helpers ----------- */
// GET /api/orders/:id/receipt  -> download PDF
export async function handleGetReceipt(req: any, res: any) {
  try {
    const orderId = Number(req.params.id);
    const pdf = await generateOrderPDFBuffer(orderId);
    res.setHeader("Content-Type", "application/pdf");
    res.setHeader(
      "Content-Disposition",
      `attachment; filename="order-${orderId}-receipt.pdf"`
    );
    res.send(pdf);
  } catch (err: any) {
    res.status(500).json({ error: err?.message || "Failed to generate receipt" });
  }
}

// POST /api/orders/:id/send-receipt  -> email PDF to customer
export async function handleSendReceipt(req: any, res: any) {
  try {
    const orderId = Number(req.params.id);
    const pdf = await generateOrderPDFBuffer(orderId);

    const order = await storage.getOrderWithItems(orderId);
    if (!order) return res.status(404).json({ error: "Order not found" });

    const user = await storage.getUser(order.userId);
    if (!user?.email) return res.status(400).json({ error: "Customer email not found" });

    const emailSvc = EmailService.getInstance();
    const ok = await emailSvc.sendEmailWithAttachment(
      {
        to: user.email,
        customerName: user.firstName || user.username,
        orderNumber: String(order.id),
        orderTotal: order.total,
        language: (user as any).preferredLanguage || "en",
      },
      "receipt",
      pdf,
      `invoice-${order.id}-${Date.now()}.pdf`
    );

    if (ok === true) return res.json({ ok: true });
    return res.status(500).json({ error: "Failed to send email" });
  } catch (err: any) {
    res.status(500).json({ error: err?.message || "Failed to send receipt" });
  }
}

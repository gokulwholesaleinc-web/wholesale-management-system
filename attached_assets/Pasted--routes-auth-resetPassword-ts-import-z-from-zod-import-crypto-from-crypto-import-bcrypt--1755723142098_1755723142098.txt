// routes/auth.resetPassword.ts
import { z } from "zod";
import crypto from "crypto";
import bcrypt from "bcryptjs";
import type { Request, Response } from "express";
import { db } from "../db"; // your DB client
import { invalidateAllSessionsForUser } from "../sessions"; // optional

const ResetSchema = z.object({
  token: z.string().min(32),
  newPassword: z.string().min(8),
});

export async function resetPasswordHandler(req: Request, res: Response) {
  const parsed = ResetSchema.safeParse(req.body);
  if (!parsed.success) return res.status(400).json({ ok: false, error: "Invalid request" });

  const { token, newPassword } = parsed.data;

  // 1) Hash token the same way you stored it
  const tokenHash = crypto.createHash("sha256").update(token, "utf8").digest("hex");

  // 2) Look up valid token & user (NOT marking used yet)
  const tokenRow = await db.password_reset_tokens.findFirst({
    where: {
      tokenHash,
      usedAt: null,
      expiresAt: { gt: new Date() },
    },
  });

  // Donâ€™t reveal which condition failed
  if (!tokenRow) return res.status(400).json({ ok: false, error: "Invalid or expired link" });

  const user = await db.users.findUnique({ where: { id: tokenRow.userId } });
  if (!user) return res.status(400).json({ ok: false, error: "Invalid or expired link" });

  // 3) Hash new password (ensure await)
  const passwordHash = await bcrypt.hash(newPassword, 12);

  // 4) Update user first, then mark token used â€” as a transaction
  await db.$transaction(async (tx) => {
    await tx.users.update({
      where: { id: user.id },
      data: {
        passwordHash,          // <-- make sure this field name matches your schema
        forcePasswordChange: false,
        tempPassword: null,
        tempPasswordExpiry: null,
      },
    });

    await tx.password_reset_tokens.update({
      where: { id: tokenRow.id },
      data: { usedAt: new Date() },
    });

    // Optional: invalidate all other outstanding tokens for this user
    await tx.password_reset_tokens.updateMany({
      where: { userId: user.id, usedAt: null, id: { not: tokenRow.id } },
      data: { usedAt: new Date() },
    });
  });

  // Optional but recommended: kill existing sessions
  await invalidateAllSessionsForUser?.(user.id).catch(() => {});

  return res.json({ ok: true });
}

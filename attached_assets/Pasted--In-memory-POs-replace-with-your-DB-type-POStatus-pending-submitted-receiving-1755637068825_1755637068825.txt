// --- In-memory POs (replace with your DB) ---
type POStatus = 'pending' | 'submitted' | 'receiving' | 'completed' | 'cancelled';

interface PurchaseOrder {
  id: number;
  orderNumber: string;
  supplierName: string;
  status: POStatus;
  totalCost: number;
  createdAt: string;
}

interface PurchaseOrderItem {
  id: number;
  purchaseOrderId: number;
  productId: number | null;     // may be null if new product to be created later
  productName: string;
  sku: string;
  quantityOrdered: number;
  unitCost: number;
  totalCost: number;
  notes?: string;
}

const poStore = {
  seq: 1000,
  itemSeq: 1,
  pos: new Map<number, PurchaseOrder>(),
  items: new Map<number, PurchaseOrderItem[]>(), // keyed by PO id
};

// --- Approve: create PO only; DO NOT update stock here ---
router.post('/invoice/:id/approve', async (req: Request, res: Response) => {
  try {
    const id = Number(req.params.id);
    const rec = store.records.get(id);
    if (!rec) return res.status(404).send('Not found');

    const { userDecisions } = req.body || {};
    if (!Array.isArray(userDecisions) || userDecisions.length === 0) {
      return res.status(400).send('No decisions provided');
    }

    // Build PO header (supplier from extracted data; default fallback)
    const supplierName =
      rec.extractedData?.supplierName ||
      rec.extractedData?.vendorName ||
      'AI Processed Supplier';

    // Create PO header (status = pending; stock will update in Receiving workflow)
    const purchaseOrderId = poStore.seq++;
    const po: PurchaseOrder = {
      id: purchaseOrderId,
      orderNumber: `AI-PO-${purchaseOrderId}`,
      supplierName,
      status: 'pending',
      totalCost: 0,
      createdAt: new Date().toISOString(),
    };
    poStore.pos.set(purchaseOrderId, po);
    poStore.items.set(purchaseOrderId, []);

    // Map decisions -> PO items (no inventory updates here)
    let runningTotal = 0;
    for (let i = 0; i < userDecisions.length; i++) {
      const d = userDecisions[i];

      // Skip lines user chose to skip
      if (d?.action === 'skip') continue;

      // Validate common fields
      const qty = Number(d?.quantity ?? 0);
      const unitCost = Number(d?.cost ?? d?.unitCost ?? 0);
      if (!qty || qty <= 0 || !Number.isFinite(qty)) {
        return res.status(400).send(`Invalid quantity in decision ${i + 1}`);
      }
      if (!Number.isFinite(unitCost)) {
        return res.status(400).send(`Invalid cost in decision ${i + 1}`);
      }

      // Build item
      const item: PurchaseOrderItem = {
        id: poStore.itemSeq++,
        purchaseOrderId,
        productId: d.action === 'map_existing' ? Number(d.productId) || null : null, // leave null for create_new
        productName:
          (d.productName ??
            d.extractedProductName ??
            'Unnamed Product') as string,
        sku: (d.sku ?? d.extractedSku ?? '').toString(),
        quantityOrdered: qty,
        unitCost,
        totalCost: unitCost * qty,
        notes: d.notes || (d.action === 'create_new' ? 'New product on receive' : undefined),
      };

      // Attach to PO
      const arr = poStore.items.get(purchaseOrderId)!;
      arr.push(item);
      runningTotal += item.totalCost;

      // IMPORTANT: No stock/cost/price mutations here.
      // Receiving workflow will:
      //  - optionally create the product if productId is null
      //  - update cost/price if chosen
      //  - increment stock by quantityReceived
    }

    // Finalize PO total
    po.totalCost = Number(runningTotal.toFixed(2));
    poStore.pos.set(purchaseOrderId, po);

    // Done â€” return the PO id
    return res.json({ purchaseOrderId, orderNumber: po.orderNumber });
  } catch (e: any) {
    console.error('Approve error:', e);
    return res.status(500).send(e?.message || 'Server error');
  }
});

// src/routes/auth.reset.ts
// Express router implementing secure tokenized, single-use password reset.
// Supports Email and optional SMS channel. Uses PUBLIC_BASE_URL for links.

import { Router, type Request, type Response } from 'express';
import crypto from 'crypto';
import { emailService } from '../services/emailService';
import { smsService } from '../services/smsService';

// Replace with your real storage and bcrypt helpers:
import { storage } from '../storage';
import { hashPassword } from '../helpers/bcrypt-helper';

const router = Router();

const REQUIRED_ENV = ['PUBLIC_BASE_URL'] as const;
function assertEnv() {
  for (const key of REQUIRED_ENV) {
    if (!process.env[key]) {
      throw new Error(`[auth.reset] Missing env ${key}`);
    }
  }
}
assertEnv();

// -----------------------------
// Token helpers
// -----------------------------
const TOKEN_BYTES = 32;               // 256-bit
const TOKEN_TTL_MINUTES = parseInt(process.env.RESET_TOKEN_TTL_MINUTES || '30', 10); // default 30m

function createResetToken() {
  const token = crypto.randomBytes(TOKEN_BYTES).toString('base64url'); // URL-safe
  const tokenHash = hashToken(token);
  const expiresAt = new Date(Date.now() + TOKEN_TTL_MINUTES * 60 * 1000);
  return { token, tokenHash, expiresAt };
}

function hashToken(token: string) {
  return crypto.createHash('sha256').update(token, 'utf8').digest('hex');
}

// -----------------------------
// Minimal storage contract (must exist in your storage):
// -----------------------------
/**
 * storage.getUserByEmail(email: string)
 * storage.getUserByUsername(username: string)
 * storage.getUserByPhone(phone: string)
 * storage.createPasswordResetToken({ userId: string, tokenHash: string, expiresAt: Date }): Promise<{id: string}>
 * storage.findPasswordResetToken(tokenHash: string): Promise<{ id: string; userId: string; expiresAt: Date; usedAt: Date|null } | null>
 * storage.markPasswordResetTokenUsed(id: string, usedAt: Date): Promise<void>
 * storage.updateUserPassword(userId: string, passwordHash: string): Promise<void>
 */

// -----------------------------
// Compose reset URL
// -----------------------------
function resetUrl(token: string) {
  const base = process.env.PUBLIC_BASE_URL!.replace(/\/+$/, '');
  return `${base}/reset-password?token=${encodeURIComponent(token)}`;
}

// -----------------------------
// Email template
// -----------------------------
function resetEmailTemplate(link: string, minutes: number) {
  const subject = 'Password Reset Request';
  const text = `We received a request to reset your password.

Use the link below to set a new password. This link expires in ${minutes} minutes.

${link}

If you did not request a password reset, you can safely ignore this message.`;

  const html = `
  <div style="font-family: Inter, Arial, sans-serif; max-width: 560px; margin: 0 auto;">
    <h2 style="margin-bottom: 8px;">Password Reset Request</h2>
    <p style="color:#444;margin:0 0 16px;">We received a request to reset your password. The link below expires in <b>${minutes} minutes</b>.</p>
    <p style="margin: 16px 0;">
      <a href="${link}" style="display:inline-block;background:#4f46e5;color:#fff;padding:10px 16px;border-radius:8px;text-decoration:none;font-weight:600">
        Set New Password
      </a>
    </p>
    <p style="color:#555;margin:16px 0;">If the button doesn't work, copy and paste this URL:</p>
    <code style="display:block;white-space:break-spaces;background:#f6f8fa;padding:12px;border-radius:8px;color:#111">${link}</code>
    <p style="color:#777;margin-top:16px;font-size:12px;">If you didnâ€™t request this, you can safely ignore this email.</p>
  </div>
  `;
  return { subject, text, html };
}

// -----------------------------
// SMS template
// -----------------------------
function resetSmsTemplate(link: string, minutes: number) {
  return `Reset your password (expires in ${minutes}m): ${link}`;
}

// -----------------------------
// POST /auth/forgot-password
// body: { emailOrUsername?: string; phone?: string; channel?: 'email' | 'sms' | 'both' }
// -----------------------------
router.post('/auth/forgot-password', async (req: Request, res: Response) => {
  try {
    const { emailOrUsername, phone, channel = 'email' } = (req.body ?? {}) as {
      emailOrUsername?: string;
      phone?: string;
      channel?: 'email' | 'sms' | 'both';
    };

    // Normalize & look up user without leaking enumeration info
    let user: any = null;
    if (emailOrUsername) {
      user = await storage.getUserByEmail(emailOrUsername.trim().toLowerCase());
      if (!user) user = await storage.getUserByUsername(emailOrUsername.trim());
    } else if (phone) {
      user = await storage.getUserByPhone(phone.trim());
    }

    // Always respond success (prevents enumeration), but only proceed internally if user exists
    if (!user) {
      // Simulate latency
      await wait(150);
      return res.status(200).json({ ok: true, message: 'If an account exists, a reset message has been sent.' });
    }

    // Create reset token & persist hash
    const { token, tokenHash, expiresAt } = createResetToken();
    await storage.createPasswordResetToken({
      userId: String(user.id),
      tokenHash,
      expiresAt,
    });

    const link = resetUrl(token);

    // Send via requested channels
    if (channel === 'email' || channel === 'both') {
      if (!user.email) {
        // Log only; do not leak to client
        console.warn('[forgot-password] user has no email on file', { userId: user.id });
      } else {
        const { subject, text, html } = resetEmailTemplate(link, TOKEN_TTL_MINUTES);
        await emailService.send({ to: user.email, subject, text, html });
      }
    }

    if (channel === 'sms' || channel === 'both') {
      if (!user.phone) {
        console.warn('[forgot-password] user has no phone on file', { userId: user.id });
      } else {
        const message = resetSmsTemplate(link, TOKEN_TTL_MINUTES);
        await smsService.send({ to: user.phone, message });
      }
    }

    return res.status(200).json({ ok: true, message: 'If an account exists, a reset message has been sent.' });
  } catch (err: any) {
    console.error('[forgot-password] error', { message: err?.message });
    // Same generic response to avoid enumeration
    return res.status(200).json({ ok: true, message: 'If an account exists, a reset message has been sent.' });
  }
});

// -----------------------------
// POST /auth/reset-password
// body: { token: string; newPassword: string }
// -----------------------------
router.post('/auth/reset-password', async (req: Request, res: Response) => {
  try {
    const { token, newPassword } = (req.body ?? {}) as { token?: string; newPassword?: string };

    if (!token || !newPassword || String(newPassword).length < 8) {
      return res.status(400).json({ ok: false, message: 'Invalid input.' });
    }

    const tokenHash = hashToken(token);
    const record = await storage.findPasswordResetToken(tokenHash);
    if (!record) {
      return res.status(400).json({ ok: false, message: 'Invalid or expired token.' });
    }

    if (record.usedAt) {
      return res.status(400).json({ ok: false, message: 'This token has already been used.' });
    }

    if (new Date(record.expiresAt).getTime() < Date.now()) {
      return res.status(400).json({ ok: false, message: 'Token has expired.' });
    }

    const passwordHash = await hashPassword(newPassword);
    await storage.updateUserPassword(String(record.userId), passwordHash);
    await storage.markPasswordResetTokenUsed(String(record.id), new Date());

    return res.status(200).json({ ok: true, message: 'Password updated successfully.' });
  } catch (err: any) {
    console.error('[reset-password] error', { message: err?.message });
    return res.status(500).json({ ok: false, message: 'Unable to reset password right now.' });
  }
});

// -----------------------------
// Utility
// -----------------------------
function wait(ms: number) {
  return new Promise((r) => setTimeout(r, ms));
}

export default router;

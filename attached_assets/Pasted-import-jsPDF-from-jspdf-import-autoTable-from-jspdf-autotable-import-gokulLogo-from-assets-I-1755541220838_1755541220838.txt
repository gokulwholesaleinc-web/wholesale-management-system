import jsPDF from "jspdf";
import autoTable from "jspdf-autotable";
import gokulLogo from "@assets/IMG_0846.png";

/** ------------ Types (with optional server fields) ------------ */
interface OrderItem {
  id: number;
  productId: number;
  quantity: number;
  price: number;
  createdAt: string | null;
  product?: { id: number; name: string; sku?: string; isTobaccoProduct?: boolean };
  productName?: string;
  flatTaxAmount?: number;      // per-line or per-unit (server dependent)
  totalTaxAmount?: number;     // per-line total tax if provided
  flatTaxName?: string;        // e.g., "Cook Co. Lg Cigar 60ct"
  isTobaccoProduct?: boolean;  // if provided on client
}

type FlatTaxLine = { name: string; amount: number; description?: string };

interface CalcLine { kind: string; label: string; amount: number; }
interface CalculationBreakdown {
  itemsSubtotal?: number;
  flatTaxTotal?: number;
  subtotalBeforeDelivery?: number;
  nonTobaccoSubtotal?: number;
  loyaltyPointsEarned?: number;
  loyaltyRedeemValue?: number;
  deliveryFee?: number;
  lines?: CalcLine[];
}

interface Order {
  id: number;
  userId: string;
  total: number;
  orderType: "delivery" | "pickup" | string;
  deliveryDate: string | null;
  deliveryTimeSlot: string | null;
  deliveryFee: number | null;
  deliveryNote: string | null;
  pickupTimeSlot: string | null;
  pickupNote: string | null;
  status: string;
  createdAt: string | null;
  updatedAt: string | null;
  items: OrderItem[];
  deliveryAddressData?: any;

  // payment / notes
  paymentMethod?: string;
  checkNumber?: string;
  paymentDate?: string;
  paymentNotes?: string;
  notes?: string;
  adminNote?: string;

  // loyalty
  loyaltyPointsRedeemed?: number;
  loyaltyPointsValue?: number;
  loyaltyPointsEarned?: number;

  // breakdowns from server (optional)
  flatTaxBreakdown?: FlatTaxLine[];
  calculationBreakdown?: CalculationBreakdown;

  // user
  user?: {
    id: string;
    firstName: string | null;
    lastName: string | null;
    company: string | null;
    businessName?: string | null;
    username: string;
  };

  // credit / previous balance (any of these may exist)
  previousBalance?: number;
  creditAccountInfo?: { previousBalance?: number };
}

/** ------------ Helpers ------------ */
const fmt$ = (n: number) => `$${Number(n || 0).toFixed(2)}`;
const asDate = (s?: string | null) => (s ? new Date(s).toLocaleDateString() : "N/A");

/** ------------ Credit: client-side fetch fallback ------------ */
/**
 * Adjust these to match your API. The first one that responds with 200 and a usable shape wins.
 * Expected JSON shapes accepted:
 *  - { previousBalance: number }
 *  - { data: { previousBalance: number } }
 *  - { credit: { previousBalance: number } }
 */
const CREDIT_ENDPOINTS = [
  (userId: string, orderId: number) => `/api/credit/summary?userId=${encodeURIComponent(userId)}&orderId=${orderId}`,
  (userId: string, orderId: number) => `/api/receipts/credit-summary?userId=${encodeURIComponent(userId)}&orderId=${orderId}`,
  (userId: string, orderId: number) => `/api/orders/previous-balance?userId=${encodeURIComponent(userId)}&excludeOrderId=${orderId}`,
];

async function fetchPreviousBalance(userId: string, orderId: number): Promise<number> {
  for (const makeUrl of CREDIT_ENDPOINTS) {
    try {
      const res = await fetch(makeUrl(userId, orderId), { method: "GET", credentials: "include" });
      if (!res.ok) continue;
      const json = await res.json();

      // Accept multiple common shapes safely:
      const pb =
        (typeof json?.previousBalance === "number" && json.previousBalance) ??
        (typeof json?.data?.previousBalance === "number" && json.data.previousBalance) ??
        (typeof json?.credit?.previousBalance === "number" && json.credit.previousBalance);

      if (typeof pb === "number" && Number.isFinite(pb)) {
        return pb;
      }
    } catch {
      // try the next endpoint
    }
  }
  return 0; // graceful fallback
}

/** Ensure we always have a previous balance number (server or client-fetched) */
async function resolvePreviousBalance(order: Order): Promise<number> {
  // Prefer server-provided values if present
  const serverPrev =
    (order as any).previousBalance ??
    order.creditAccountInfo?.previousBalance;

  if (typeof serverPrev === "number" && Number.isFinite(serverPrev)) {
    return serverPrev;
  }

  // Otherwise, fetch from API based on userId/orderId
  if (order?.userId && typeof order.id === "number") {
    return await fetchPreviousBalance(order.userId, order.id);
  }

  return 0;
}

/** ------------ Main: build PDF (client-side) ------------ */
export const generateOrderPDF = async (order: Order, customerName?: string) => {
  const doc = new jsPDF();

  // ---------- Header with transparent logo ----------
  try {
    doc.addImage(gokulLogo, "PNG", 20, 10, 25, 25);
  } catch {
    // ignore logo errors
  }

  doc.setFont("helvetica", "bold").setFontSize(18);
  doc.text("Gokul Wholesale Inc.", 50, 20);

  doc.setFont("helvetica", "normal").setFontSize(10);
  doc.text("1141 W Bryn Mawr Ave, Itasca, IL 60143", 50, 28);
  doc.text("(630) 540-9910 | sales@gokulwholesaleinc.com", 50, 34);
  doc.text("TP# 97239", 50, 40);

  doc.setFont("helvetica", "bold").setFontSize(12);
  doc.text(`Order #${order.id}`, 180, 20, { align: "right" });

  doc.setFont("helvetica", "normal").setFontSize(10);
  doc.text(`Date: ${asDate(order.createdAt)}`, 180, 28, { align: "right" });

  // thin divider
  doc.setLineWidth(0.5);
  doc.line(15, 45, 195, 45);

  // ---------- Customer & order info ----------
  const displayCustomerName =
    customerName ||
    order.user?.company ||
    order.user?.businessName ||
    (order.user?.firstName && order.user?.lastName
      ? `${order.user.firstName} ${order.user.lastName}`
      : "") ||
    order.user?.username ||
    "Customer";

  let y = 54;

  // Gray panel
  doc.setFillColor(240, 240, 240);
  doc.rect(15, y, 180, 22, "F");

  doc.setFont("helvetica", "bold").setFontSize(11).setTextColor(33, 37, 41);
  doc.text("Customer Information", 20, y + 7);

  doc.setFont("helvetica", "normal").setFontSize(10);
  doc.text(displayCustomerName, 20, y + 15);
  doc.text(`Email: sales@gokulwholesaleinc.com`, 120, y + 11);
  doc.text(`Phone: +12242601982`, 120, y + 17);

  y += 30;

  // Order type/date/time (compact)
  doc.setFont("helvetica", "normal").setFontSize(10);
  const orderType = order.orderType === "delivery" ? "DELIVERY" : "PICKUP";
  doc.text(`Order Type: ${orderType}`, 20, y);
  y += 6;

  // ---------- Items table ----------
  const tableStartY = y + 4;
  const tableRows = order.items.map((it) => [
    it.product?.name || it.productName || "Product",
    it.product?.sku || "N/A",
    String(it.quantity),
    fmt$(it.price),
    fmt$(it.quantity * it.price),
  ]);

  autoTable(doc, {
    startY: tableStartY,
    head: [["Item Description", "SKU", "Qty", "Unit Price", "Total"]],
    body: tableRows,
    theme: "grid",
    headStyles: { fillColor: [38, 60, 82], textColor: 255, fontStyle: "bold" },
    styles: { fontSize: 9, cellPadding: 3 },
    columnStyles: {
      0: { cellWidth: 78 },                  // Description
      1: { cellWidth: 32 },                  // SKU
      2: { cellWidth: 15, halign: "center" },// Qty
      3: { cellWidth: 25, halign: "right" }, // Unit Price
      4: { cellWidth: 25, halign: "right" }, // Total
    },
  });

  const afterTableY = (doc as any).lastAutoTable.finalY + 10;

  // ---------- Totals + Breakdown ----------
  // Subtotals
  const itemsSubtotal = order.items.reduce(
    (sum, it) => sum + (it.price || 0) * (it.quantity || 0),
    0
  );

  // Build flat-tax lines (prefer server-provided)
  let flatTaxLines: FlatTaxLine[] = [];
  if (Array.isArray(order.flatTaxBreakdown) && order.flatTaxBreakdown.length) {
    flatTaxLines = order.flatTaxBreakdown.map((l) => ({
      name: l.name,
      amount: Number(l.amount || 0),
    }));
  } else if (
    order.calculationBreakdown?.lines &&
    order.calculationBreakdown.lines.length
  ) {
    flatTaxLines = order.calculationBreakdown.lines
      .filter((l) => l.kind === "flatTax")
      .map((l) => ({ name: l.label, amount: Number(l.amount || 0) }));
  } else {
    // Fallback: try to group on item.flatTaxName or combine into one line
    const byName: Record<string, number> = {};
    for (const it of order.items) {
      const amt = (it.totalTaxAmount ?? it.flatTaxAmount ?? 0) as number;
      if (!amt) continue;
      const lbl = it.flatTaxName || "Flat Taxes";
      byName[lbl] = (byName[lbl] || 0) + Number(amt);
    }
    flatTaxLines = Object.entries(byName).map(([name, amount]) => ({
      name,
      amount,
    }));
  }
  const flatTaxTotal = flatTaxLines.reduce((s, l) => s + l.amount, 0);

  const deliveryFee = Number(order.deliveryFee || 0);
  const loyaltyRedeemValue = Number(order.loyaltyPointsValue || 0);

  // Loyalty points earned: prefer server value; else compute from non-tobacco subtotal
  const nonTobaccoSubtotal =
    order.calculationBreakdown?.nonTobaccoSubtotal ??
    order.items.reduce(
      (s, it) =>
        (it.isTobaccoProduct || it.product?.isTobaccoProduct)
          ? s
          : s + (it.price || 0) * (it.quantity || 0),
      0
    );

  const loyaltyEarned =
    typeof order.loyaltyPointsEarned === "number"
      ? order.loyaltyPointsEarned
      : Math.round((nonTobaccoSubtotal || 0) * 2); // 2 points per $1

  // This order total (recomputed for display only)
  const displayedThisOrderTotal =
    itemsSubtotal + flatTaxTotal + deliveryFee - loyaltyRedeemValue;

  // Use server snapshot as authoritative "Total (This Order)"
  const serverThisOrderTotal = Number(order.total || displayedThisOrderTotal);

  // --------- Resolve Previous Balance (server-provided OR client-fetched) ---------
  const previousBalance = await resolvePreviousBalance(order);

  // Amount due = previous balance + this order (server snapshot)
  const amountDue = previousBalance + serverThisOrderTotal;

  // Render breakdown (right-aligned block)
  let sx = 120;
  let sy = afterTableY;

  doc.setFont("helvetica", "normal").setFontSize(11);

  // Items Subtotal
  doc.text("Items Subtotal:", sx, sy);
  doc.text(fmt$(itemsSubtotal), 195, sy, { align: "right" });
  sy += 7;

  // Flat-tax lines
  for (const line of flatTaxLines) {
    doc.text(`${line.name}:`, sx, sy);
    doc.text(fmt$(line.amount), 195, sy, { align: "right" });
    sy += 7;
  }

  // Subtotal (Items + Taxes)
  if (flatTaxLines.length > 0) {
    doc.setFont("helvetica", "bold");
    doc.text("Subtotal (Items + Taxes):", sx, sy);
    doc.text(fmt$(itemsSubtotal + flatTaxTotal), 195, sy, { align: "right" });
    sy += 7;
    doc.setFont("helvetica", "normal");
  }

  // Delivery Fee
  if (deliveryFee > 0) {
    doc.text("Delivery Fee:", sx, sy);
    doc.text(fmt$(deliveryFee), 195, sy, { align: "right" });
    sy += 7;
  }

  // Loyalty redeemed (always show if provided, even 0)
  if (order.loyaltyPointsRedeemed != null) {
    doc.text(
      `Loyalty Redeemed: ${order.loyaltyPointsRedeemed} pts`,
      sx,
      sy
    );
    doc.text(`-${fmt$(loyaltyRedeemValue)}`, 195, sy, { align: "right" });
    sy += 7;
  }

  // Previous Balance (ALWAYS)
  doc.text("Previous Balance:", sx, sy);
  doc.text(fmt$(previousBalance), 195, sy, { align: "right" });
  sy += 4;

  // Divider
  doc.setLineWidth(0.5);
  doc.line(sx, sy, 195, sy);
  sy += 6;

  // Totals
  doc.setFont("helvetica", "bold");
  doc.text("Total (This Order):", sx, sy);
  doc.text(fmt$(serverThisOrderTotal), 195, sy, { align: "right" });
  sy += 7;

  doc.text("Amount Due (Prev + This):", sx, sy);
  doc.text(fmt$(amountDue), 195, sy, { align: "right" });
  sy += 12;

  // ---------- Loyalty points earned (banner) ----------
  if (loyaltyEarned >= 0) {
    doc.setFillColor(240, 248, 240);
    doc.rect(15, sy - 6, 180, 10, "F");
    doc.setTextColor(39, 174, 96);
    doc.setFont("helvetica", "bold").setFontSize(10);
    doc.text(`Loyalty Points Earned: ${loyaltyEarned} points`, 20, sy + 1);
    doc.setTextColor(0, 0, 0);
    sy += 14;
  }

  // ---------- Tobacco notice (bottom-left small box; always show) ----------
  const pageH = (doc as any).internal.pageSize.height;
  const boxY = pageH - 28;
  doc.setDrawColor(230, 126, 34).setLineWidth(0.6);
  doc.rect(15, boxY, 80, 10);
  doc.setFont("helvetica", "bold").setFontSize(9).setTextColor(230, 126, 34);
  doc.text("45% IL TOBACCO TAX PAID", 55, boxY + 6, { align: "center" });
  doc.setTextColor(0, 0, 0);

  // ---------- Footer ----------
  doc.setFont("helvetica", "normal").setFontSize(9);
  doc.text("Thank you for your business!", 105, pageH - 14, { align: "center" });
  doc.text("www.shopgokul.com", 105, pageH - 8, { align: "center" });

  return doc;
};

/** Save to file */
export const downloadOrderPDF = async (order: Order, customerName?: string) => {
  const doc = await generateOrderPDF(order, customerName);
  doc.save(`Order-${order.id}-${Date.now()}.pdf`);
};

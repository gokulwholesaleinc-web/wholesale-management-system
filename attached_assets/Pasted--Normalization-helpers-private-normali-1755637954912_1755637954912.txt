// --------------------------
// Normalization helpers
// --------------------------
private normalizeText(s: string): string {
  return (s || '')
    .toLowerCase()
    .replace(/twangerz/g, 'twang')            // brand normalization
    .replace(/[^a-z0-9]+/g, ' ')              // collapse punctuation
    .replace(/\s+/g, ' ')
    .trim();
}

private normalizeSKU(s: string): string {
  return (s || '').toLowerCase().replace(/[^a-z0-9]/g, '');
}

// --------------------------
// Jaro-Winkler similarity (0..1)
// --------------------------
private jaroWinkler(a: string, b: string): number {
  if (!a || !b) return 0;
  const s1 = a, s2 = b;
  const mRange = Math.max(0, Math.floor(Math.max(s1.length, s2.length) / 2) - 1);

  const s1Matches: boolean[] = Array(s1.length).fill(false);
  const s2Matches: boolean[] = Array(s2.length).fill(false);

  let matches = 0;
  for (let i = 0; i < s1.length; i++) {
    const start = Math.max(0, i - mRange);
    const end = Math.min(i + mRange + 1, s2.length);
    for (let j = start; j < end; j++) {
      if (s2Matches[j] || s1[i] !== s2[j]) continue;
      s1Matches[i] = true;
      s2Matches[j] = true;
      matches++;
      break;
    }
  }
  if (!matches) return 0;

  let transpositions = 0;
  let k = 0;
  for (let i = 0; i < s1.length; i++) {
    if (!s1Matches[i]) continue;
    while (!s2Matches[k]) k++;
    if (s1[i] !== s2[k]) transpositions++;
    k++;
  }
  transpositions /= 2;

  const j = (matches / s1.length + matches / s2.length + (matches - transpositions) / matches) / 3;

  // Winkler prefix boost
  let prefix = 0;
  for (let i = 0; i < Math.min(4, s1.length, s2.length); i++) {
    if (s1[i] === s2[i]) prefix++;
    else break;
  }
  const p = 0.1;
  return j + prefix * p * (1 - j);
}

// --------------------------
// Token-set/Dice similarity (for names/descriptions)
// --------------------------
private tokenSetDice(a: string, b: string): number {
  const tok = (s: string) => this.normalizeText(s).split(' ').filter(Boolean);
  const A = new Set(tok(a));
  const B = new Set(tok(b));
  if (A.size === 0 || B.size === 0) return 0;
  let intersect = 0;
  A.forEach(t => { if (B.has(t)) intersect++; });
  return (2 * intersect) / (A.size + B.size); // Dice coefficient 0..1
}

// --------------------------
// SKU similarity: Levenshtein + JW + containment
// --------------------------
private skuSimilarity(a: string, b: string): number {
  const s1 = this.normalizeSKU(a);
  const s2 = this.normalizeSKU(b);
  if (!s1 || !s2) return 0;
  if (s1 === s2) return 1;

  // exact containment (OCR knocks a dash/space) → strong 0.90
  if (s1.includes(s2) || s2.includes(s1)) return 0.90;

  // Levenshtein-based similarity
  const levSim = this.calculateFuzzyMatch(s1, s2); // you already have this (0..1)
  const jw = this.jaroWinkler(s1, s2);

  // If 1 edit distance off (very likely OCR or minor typo) → ≥0.95
  const levDistanceLikely = Math.round((1 - levSim) * Math.max(s1.length, s2.length));
  const nearMiss = levDistanceLikely <= 1 ? 0.95 : 0;

  return Math.max(nearMiss, (levSim * 0.6) + (jw * 0.4));
}

// --------------------------
// Name/description combined similarity 0..1
// --------------------------
private nameDescriptionSimilarity(itemName: string, productName: string, itemDesc: string, productDesc: string): number {
  const n1 = this.normalizeText(itemName);
  const n2 = this.normalizeText(productName);
  if (!n1 && !n2) return 0;

  const jw = this.jaroWinkler(n1, n2);
  const dice = this.tokenSetDice(n1, n2);

  let descScore = 0;
  if (itemDesc && productDesc) {
    const d1 = this.normalizeText(itemDesc);
    const d2 = this.normalizeText(productDesc);
    descScore = d1 && d2 ? this.jaroWinkler(d1, d2) : 0;
  }

  // Weighted combo: token set catches reordering; JW catches minor typos
  return (dice * 0.55) + (jw * 0.35) + (descScore * 0.10);
}

// --------------------------
// MAIN MATCHER
// --------------------------
private async findBestProductMatch(
  item: any,
  products: any[]
): Promise<{ id: number; confidence: number; reasoning: string } | null> {
  try {
    const itemName = this.normalizeText(item.productName || '');
    const itemSkuRaw = item.sku || '';
    const itemSku = this.normalizeSKU(itemSkuRaw);
    const itemDescription = this.normalizeText(item.description || '');

    let best: { id: number; confidence: number; reasoning: string } | null = null;
    let bestScore = 0;
    let bestWhy = '';

    for (const product of products) {
      const pName = this.normalizeText(product.name || '');
      const pSku = this.normalizeSKU(product.sku || '');
      const pDesc = this.normalizeText(product.description || '');
      const brand = this.normalizeText(product.brand || '');

      const reasons: string[] = [];
      let score = 0;

      // 1) Strong SKU signal
      let skuScore = 0;
      if (itemSku && pSku) {
        skuScore = this.skuSimilarity(itemSku, pSku); // 0..1
        if (skuScore >= 0.99) { score = 1; reasons.push('Exact SKU match'); }
        else if (skuScore >= 0.95) { score = Math.max(score, 0.95); reasons.push('1-edit SKU near-match'); }
        else if (skuScore >= 0.90) { score = Math.max(score, 0.90); reasons.push('High SKU similarity / containment'); }
      }

      // 2) Names/descriptions
      const ndScore = this.nameDescriptionSimilarity(itemName, pName, itemDescription, pDesc); // 0..1
      if (ndScore >= 0.8) reasons.push(`High name/desc similarity (${Math.round(ndScore * 100)}%)`);
      else if (ndScore >= 0.6) reasons.push(`Moderate name/desc similarity (${Math.round(ndScore * 100)}%)`);

      // 3) Brand presence (light bonus)
      let brandBonus = 0;
      if (brand && (itemName.includes(brand) || pName.includes(brand))) {
        brandBonus = 0.05;
        reasons.push('Brand match');
      }

      // Final weighted score:
      // - If SKU exists, it dominates. Otherwise rely on names/descriptions
      const combined = Math.max(
        skuScore,                            // respect strong SKU matches
        (ndScore * 0.92) + brandBonus        // otherwise quality name/desc + brand
      );

      // Keep the maximum of any signal so a strong SKU doesn't get diluted
      score = Math.max(score, combined);

      // Lower the consideration floor to 0.30 so we don't drop “some similarity” to 0.
      if (score > bestScore) {
        bestScore = score;
        bestWhy = reasons.length ? reasons.join(', ') : 'Similarity across fields';
        best = {
          id: product.id,
          confidence: Math.round(score * 100),
          reasoning: bestWhy,
        };
      }
    }

    if (best) {
      // Debug
      console.log(`🎯 Best match for "${item.productName}" → Product #${best.id} @ ${best.confidence}% (${best.reasoning})`);
    }

    return best; // may be <50% but never forced to 0 if there’s evidence
  } catch (err) {
    console.error('Error in findBestProductMatch:', err);
    return null;
  }
}

// src/services/passwordResetService.ts
import crypto from 'crypto';
import bcrypt from 'bcryptjs';
import { emailService } from '@/services/emailService';
import { smsService } from '@/services/smsService';
import { Storage, User, AppError } from '@/types/auth';

const TOKEN_BYTES = 32;
const TOKEN_TTL_MIN = Number(process.env.PASSWORD_RESET_TTL_MIN || 30);

const PUBLIC_APP_URL = process.env.PUBLIC_APP_URL!; // e.g. https://app.yourdomain.com

export class PasswordResetService {
  constructor(private storage: Storage) {}

  /** Creates a one-time, expiring token and sends via chosen channel */
  async initiatePasswordReset(
    emailOrUsername: string,
    channel: 'email' | 'sms' = 'email',
    opts?: { phoneNumber?: string; ip?: string | null; userAgent?: string | null }
  ): Promise<{ success: boolean; message: string }> {
    const user = await this.findUser(emailOrUsername);
    if (!user) throw new AppError('No account found with this email or username.', 404);

    const token = crypto.randomBytes(TOKEN_BYTES).toString('base64url'); // safe for URLs
    const tokenHash = await bcrypt.hash(token, 12);
    const expiresAt = new Date(Date.now() + TOKEN_TTL_MIN * 60 * 1000);

    // Persist required fields
    await this.storage.updateUser({
      id: user.id,
      resetTokenHash: tokenHash,
      resetTokenExpiresAt: expiresAt,
      resetTokenUsedAt: null,
      // clear legacy temp password flags if present
      tempPassword: null,
      tempPasswordExpiry: null,
      forcePasswordChange: true,
    });

    await this.storage.createPasswordResetEvent({
      userId: user.id,
      tokenHash,
      expiresAt,
      channel,
      ip: opts?.ip ?? null,
      userAgent: opts?.userAgent ?? null,
    });

    const resetUrl = `${PUBLIC_APP_URL.replace(/\/$/, '')}/reset-password?token=${encodeURIComponent(token)}`;

    if (channel === 'email') {
      if (!user.email) throw new AppError('User has no email on file.', 400);
      await emailService.sendEmail({
        to: user.email,
        subject: 'Password reset requested',
        html: this.renderResetEmail({ user, resetUrl, expiresAt }),
        text: this.renderResetText({ resetUrl, expiresAt }),
      });
    } else {
      const to = opts?.phoneNumber;
      if (!to) throw new AppError('Phone number required for SMS reset.', 400);
      await smsService.sendSMS({
        to,
        message: `Reset your password: ${resetUrl} (expires ${expiresAt.toLocaleString()})`,
      });
    }

    return { success: true, message: 'Reset link sent.' };
  }

  async validateToken(token: string): Promise<User> {
    const user = await this.findByToken(token);
    if (!user) throw new AppError('Invalid or expired token.', 400);
    return user;
  }

  async completeReset(token: string, newPassword: string): Promise<{ success: boolean }> {
    const user = await this.findByToken(token);
    if (!user) throw new AppError('Invalid or expired token.', 400);

    const passwordHash = await bcrypt.hash(newPassword, 12);
    await this.storage.updateUser({
      id: user.id,
      passwordHash,
      resetTokenHash: null,
      resetTokenExpiresAt: null,
      resetTokenUsedAt: new Date(),
      forcePasswordChange: false,
    });
    return { success: true };
  }

  // ---------- helpers ----------
  private async findUser(emailOrUsername: string) {
    const byEmail = await this.storage.getUserByEmail(emailOrUsername);
    if (byEmail) return byEmail;
    return this.storage.getUserByUsername(emailOrUsername);
  }

  private async findByToken(token: string) {
    // We can't query by token directly (we only stored a hash).
    // Strategy: find the user(s) with a currently valid hash and compare.
    // Ideally you keep a small table keyed by userId to avoid scanning.
    const candidates = [
      await this.storage.getUserByEmail(token), // always null; placeholder to show shape
    ];
    // Replace the above with a proper storage.getUsersWithActiveResetToken(expiresAfterNow)
    // For now, weâ€™ll assume you can fetch the current user via session or separate lookup.
    // If not available, extend Storage with a method to query by non-null resetTokenHash.

    // TEMP fallback: throw if your storage cannot look up by token-hash
    throw new AppError(
      'Server is missing a lookup by active reset token. Implement storage.getUserByActiveResetToken(expiresAfterNow) and compare with bcrypt.',
      500
    );
  }

  private renderResetEmail({ user, resetUrl, expiresAt }: { user: User; resetUrl: string; expiresAt: Date }) {
    const date = new Intl.DateTimeFormat('en-US', {
      dateStyle: 'short',
      timeStyle: 'long',
      timeZone: process.env.RESET_EMAIL_TZ || 'America/Chicago',
    }).format(expiresAt);

    return `
      <div style="font-family: Inter, Arial, sans-serif">
        <h2>Password reset requested</h2>
        <p>Hi ${user.firstName || user.username}, click the button below to reset your password.</p>
        <p>
          <a href="${resetUrl}" style="background:#2563eb;color:#fff;padding:10px 16px;border-radius:8px;text-decoration:none">
            Reset your password
          </a>
        </p>
        <p>This link expires at <strong>${date}</strong> and can be used once.</p>
        <p>If the button doesn't work, copy this URL:</p>
        <code style="display:block;padding:8px;background:#f4f4f5;border-radius:6px">${resetUrl}</code>
      </div>
    `;
  }

  private renderResetText({ resetUrl, expiresAt }: { resetUrl: string; expiresAt: Date }) {
    const date = new Intl.DateTimeFormat('en-US', {
      dateStyle: 'short',
      timeStyle: 'long',
      timeZone: process.env.RESET_EMAIL_TZ || 'America/Chicago',
    }).format(expiresAt);
    return `Password reset requested.\nReset link: ${resetUrl}\nExpires: ${date}`;
  }
}
